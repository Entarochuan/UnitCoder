{"id": "e5bbbacc-eb58-3e88-964b-1a82b05055a6_1", "original": {"code": "def make_char_alphabet(text):\n    \"\"\"\n    Create a dictionary mapping characters to integers.\n    The characters are sorted and then mapped to their index in the sorted list.\n    This creates a unique integer representation for each character.\n    \"\"\"\n    chars = sorted(list(set(text)))\n    return dict((char, chars.index(char)) for char in chars)\n", "test_code": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test purpose: Verify the function handles normal alphanumeric and special character input\n        text = \"hello world!\"\n        expected = {' ': 0, '!': 1, 'd': 2, 'e': 3, 'h': 4, 'l': 5, 'o': 6, 'r': 7, 'w': 8}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test purpose: Verify the function works with empty string input\n        text = \"\"\n        expected = {}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test purpose: Verify the function handles single character input\n        text = \"a\"\n        expected = {'a': 0}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_4(self):\n        # Test purpose: Verify the function handles repeated characters (duplicates are removed)\n        text = \"aaaa\"\n        expected = {'a': 0}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_5(self):\n        # Test purpose: Verify the function correctly sorts characters by ASCII value\n        text = \"cba\"\n        expected = {'a': 0, 'b': 1, 'c': 2}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_6(self):\n        # Test purpose: Verify the function handles mixed case letters\n        text = \"aA\"\n        expected = {'A': 0, 'a': 1}  # ASCII: 'A'=65, 'a'=97\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_7(self):\n        # Test purpose: Verify the function handles digits and special characters\n        text = \"1a!9\"\n        expected = {'!': 0, '1': 1, '9': 2, 'a': 3}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)", "status": ["pass", {}]}, "debug_rounds": [], "polished": true, "polished_result": null, "polish": {"code": "import string\nfrom typing import Dict, Union\n\n\ndef make_char_alphabet(text: str) -> Dict[str, int]:\n    \"\"\"\n    Create a dictionary mapping each unique character in the input text to a unique integer index.\n    \n    The mapping is based on the sorted order of unique characters (by their ASCII/Unicode values).\n    Each character is assigned an index corresponding to its position in the sorted list of unique characters.\n    This function is useful for creating character-level encodings, such as in text preprocessing for machine learning.\n\n    Parameters:\n    -----------\n    text : str\n        The input string from which to create the character-to-integer mapping.\n        Can be any string, including empty strings, alphanumeric text, special characters, etc.\n\n    Returns:\n    --------\n    Dict[str, int]\n        A dictionary where keys are unique characters from the input text, and values are\n        integers representing the index of each character in the sorted list of unique characters.\n        If the input is an empty string, an empty dictionary is returned.\n\n    Requirements:\n    -------------\n    - Input must be a string. Non-string inputs will raise a TypeError.\n    \n    Raises:\n    -------\n    TypeError\n        If the input `text` is not a string.\n\n    Examples:\n    ---------\n    >>> make_char_alphabet(\"hello world!\")\n    {' ': 0, '!': 1, 'd': 2, 'e': 3, 'h': 4, 'l': 5, 'o': 6, 'r': 7, 'w': 8}\n\n    >>> make_char_alphabet(\"\")\n    {}\n\n    >>> make_char_alphabet(\"a\")\n    {'a': 0}\n\n    >>> make_char_alphabet(\"cba\")\n    {'a': 0, 'b': 1, 'c': 2}\n\n    >>> make_char_alphabet(\"aA\")\n    {'A': 0, 'a': 1}  # 'A' (ASCII 65) comes before 'a' (ASCII 97)\n    \"\"\"\n    \n    # Input validation: Ensure the input is a string\n    if not isinstance(text, str):\n        raise TypeError(f\"Expected input 'text' to be a string, but got {type(text).__name__}\")\n\n    # Handle empty string case early for efficiency\n    if len(text) == 0:\n        return {}\n\n    # Extract unique characters from the text using set, then sort them by ASCII/Unicode value\n    # Using sorted() on a set ensures we get a list of unique characters in ascending order\n    unique_chars = sorted(set(text))\n    \n    # Create a dictionary mapping each character to its index in the sorted list\n    # This ensures consistent and predictable integer assignments based on character order\n    char_to_index = {char: idx for idx, char in enumerate(unique_chars)}\n    \n    return char_to_index\n\n\n# Optional: Additional utility function to reverse the mapping (index to character)\ndef make_index_alphabet(text: str) -> Dict[int, str]:\n    \"\"\"\n    Create a reverse mapping from indices to characters based on the same sorting logic.\n    \n    Useful for decoding integer sequences back into characters.\n    \n    Parameters:\n    -----------\n    text : str\n        The input string to base the mapping on.\n        \n    Returns:\n    --------\n    Dict[int, str]\n        A dictionary mapping integer indices to their corresponding characters.\n    \"\"\"\n    char_alphabet = make_char_alphabet(text)\n    return {idx: char for char, idx in char_alphabet.items()}", "test_code": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test purpose: Verify the function handles normal alphanumeric and special character input\n        text = \"hello world!\"\n        expected = {' ': 0, '!': 1, 'd': 2, 'e': 3, 'h': 4, 'l': 5, 'o': 6, 'r': 7, 'w': 8}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_2(self):\n        # Test purpose: Verify the function works with empty string input\n        text = \"\"\n        expected = {}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_3(self):\n        # Test purpose: Verify the function handles single character input\n        text = \"a\"\n        expected = {'a': 0}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_4(self):\n        # Test purpose: Verify the function handles repeated characters (duplicates are removed)\n        text = \"aaaa\"\n        expected = {'a': 0}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_5(self):\n        # Test purpose: Verify the function correctly sorts characters by ASCII value\n        text = \"cba\"\n        expected = {'a': 0, 'b': 1, 'c': 2}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_6(self):\n        # Test purpose: Verify the function handles mixed case letters\n        text = \"aA\"\n        expected = {'A': 0, 'a': 1}  # ASCII: 'A'=65, 'a'=97\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)\n\n    def test_case_7(self):\n        # Test purpose: Verify the function handles digits and special characters\n        text = \"1a!9\"\n        expected = {'!': 0, '1': 1, '9': 2, 'a': 3}\n        result = make_char_alphabet(text)\n        self.assertEqual(result, expected)", "status": ["pass", {}], "timestamp": "2025-08-27T14:31:42.757037"}}
{"id": "fae1edc5-6774-353f-b90b-fe4320ffeeb3_2", "original": {"code": "def get_best_video(variants):\n    highest = variants[0]\n    for v in variants:\n        if v['content_type'] == 'video/mp4':\n            if highest['bitrate'] < v['bitrate']:\n                highest = v\n    return highest['url']\n", "test_code": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test purpose: Verify the function returns the correct URL for the highest bitrate video/mp4 variant\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 1000},\n            {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 750}\n        ]\n        self.assertEqual(get_best_video(variants), 'url2')\n\n    def test_case_2(self):\n        # Test purpose: Verify the function handles a single video variant correctly\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500}\n        ]\n        self.assertEqual(get_best_video(variants), 'url1')\n\n    def test_case_3(self):\n        # Test purpose: Verify the function ignores non-video/mp4 content types and selects only from video/mp4\n        variants = [\n            {'url': 'url1', 'content_type': 'audio/mpeg', 'bitrate': 2000},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 800},\n            {'url': 'url3', 'content_type': 'application/x-mpegURL', 'bitrate': 3000}\n        ]\n        self.assertEqual(get_best_video(variants), 'url2')\n\n    def test_case_4(self):\n        # Test purpose: Verify the function works when video/mp4 variants are not in order of bitrate\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 1200},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 600},\n            {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 1500},\n            {'url': 'url4', 'content_type': 'video/mp4', 'bitrate': 900}\n        ]\n        self.assertEqual(get_best_video(variants), 'url3')\n\n    def test_case_5(self):\n        # Test purpose: Verify the function raises an IndexError when given an empty list\n        with self.assertRaises(IndexError):\n            get_best_video([])", "status": ["fail", {"test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 35, in test_case_3\nAssertionError: 'url1' != 'url2'\n- url1\n?    ^\n+ url2\n?    ^\n\n"}]}, "debug_rounds": [[{"code": "def get_best_video(variants):\n    highest = None\n    for v in variants:\n        if v['content_type'] == 'video/mp4':\n            if highest is None or v['bitrate'] > highest['bitrate']:\n                highest = v\n    if highest is None:\n        raise IndexError(\"No video/mp4 variant found\")\n    return highest['url']", "test_code": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test purpose: Verify the function returns the correct URL for the highest bitrate video/mp4 variant\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 1000},\n            {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 750}\n        ]\n        self.assertEqual(get_best_video(variants), 'url2')\n\n    def test_case_2(self):\n        # Test purpose: Verify the function handles a single video variant correctly\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500}\n        ]\n        self.assertEqual(get_best_video(variants), 'url1')\n\n    def test_case_3(self):\n        # Test purpose: Verify the function ignores non-video/mp4 content types and selects only from video/mp4\n        variants = [\n            {'url': 'url1', 'content_type': 'audio/mpeg', 'bitrate': 2000},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 800},\n            {'url': 'url3', 'content_type': 'application/x-mpegURL', 'bitrate': 3000}\n        ]\n        self.assertEqual(get_best_video(variants), 'url2')\n\n    def test_case_4(self):\n        # Test purpose: Verify the function works when video/mp4 variants are not in order of bitrate\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 1200},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 600},\n            {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 1500},\n            {'url': 'url4', 'content_type': 'video/mp4', 'bitrate': 900}\n        ]\n        self.assertEqual(get_best_video(variants), 'url3')\n\n    def test_case_5(self):\n        # Test purpose: Verify the function raises an IndexError when given an empty list\n        with self.assertRaises(IndexError):\n            get_best_video([])", "status": ["pass", {}], "round": 0}, {"code": "def get_best_video(variants):\n    highest = None\n    for v in variants:\n        if v['content_type'] == 'video/mp4':\n            if highest is None or v['bitrate'] > highest['bitrate']:\n                highest = v\n    if highest is None:\n        raise IndexError(\"No video/mp4 variant found\")\n    return highest['url']", "test_code": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test purpose: Verify the function returns the correct URL for the highest bitrate video/mp4 variant\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 1000},\n            {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 750}\n        ]\n        self.assertEqual(get_best_video(variants), 'url2')\n\n    def test_case_2(self):\n        # Test purpose: Verify the function handles a single video variant correctly\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500}\n        ]\n        self.assertEqual(get_best_video(variants), 'url1')\n\n    def test_case_3(self):\n        # Test purpose: Verify the function ignores non-video/mp4 content types and selects only from video/mp4\n        variants = [\n            {'url': 'url1', 'content_type': 'audio/mpeg', 'bitrate': 2000},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 800},\n            {'url': 'url3', 'content_type': 'application/x-mpegURL', 'bitrate': 3000}\n        ]\n        self.assertEqual(get_best_video(variants), 'url2')\n\n    def test_case_4(self):\n        # Test purpose: Verify the function works when video/mp4 variants are not in order of bitrate\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 1200},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 600},\n            {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 1500},\n            {'url': 'url4', 'content_type': 'video/mp4', 'bitrate': 900}\n        ]\n        self.assertEqual(get_best_video(variants), 'url3')\n\n    def test_case_5(self):\n        # Test purpose: Verify the function raises an IndexError when given an empty list\n        with self.assertRaises(IndexError):\n            get_best_video([])", "status": ["pass", {}], "round": 0}]], "polished": true, "polished_result": null, "polish": {"code": "import typing\nfrom typing import List, Dict, Optional\n\n\ndef get_best_video(variants: List[Dict[str, typing.Any]]) -> str:\n    \"\"\"\n    Find and return the URL of the highest bitrate video/mp4 variant from a list of media variants.\n    \n    This function filters through a list of media variants (typically from a streaming manifest)\n    and selects the one with the highest bitrate among those with content type 'video/mp4'.\n    If no video/mp4 variant is found, it raises an IndexError.\n    \n    Args:\n        variants: A list of dictionaries representing media variants. Each dictionary should contain:\n                 - 'url' (str): The URL to the media resource\n                 - 'content_type' (str): The MIME type of the media (e.g., 'video/mp4')\n                 - 'bitrate' (int or float): The bitrate of the media in bits per second\n    \n    Returns:\n        str: The URL of the video/mp4 variant with the highest bitrate.\n    \n    Raises:\n        IndexError: If no variant with content_type 'video/mp4' is found in the input list.\n        KeyError: If any video/mp4 variant is missing required keys ('url', 'content_type', or 'bitrate').\n        TypeError: If the input is not a list or if bitrate values are not numeric.\n    \n    Requirements:\n        - Input must be a list of dictionaries\n        - At least one dictionary must have 'content_type' == 'video/mp4'\n        - All video/mp4 variants must have 'url', 'content_type', and 'bitrate' keys\n    \n    Examples:\n        >>> variants = [\n        ...     {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500},\n        ...     {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 1000},\n        ...     {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 750}\n        ... ]\n        >>> get_best_video(variants)\n        'url2'\n        \n        >>> variants = [\n        ...     {'url': 'url1', 'content_type': 'audio/mpeg', 'bitrate': 2000},\n        ...     {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 800}\n        ... ]\n        >>> get_best_video(variants)\n        'url2'\n    \"\"\"\n    # Input validation\n    if not isinstance(variants, list):\n        raise TypeError(f\"Expected list of variants, got {type(variants).__name__}\")\n    \n    # Initialize variable to track the highest bitrate video/mp4 variant\n    highest_bitrate_variant: Optional[Dict[str, typing.Any]] = None\n    \n    # Iterate through all variants to find the best video/mp4 option\n    for variant in variants:\n        # Validate that the variant is a dictionary\n        if not isinstance(variant, dict):\n            continue  # Skip non-dictionary items\n            \n        # Check if this variant is a video/mp4\n        content_type = variant.get('content_type', '')\n        if content_type != 'video/mp4':\n            continue  # Skip non-video/mp4 variants\n        \n        # Ensure required keys exist\n        if 'bitrate' not in variant:\n            raise KeyError(\"Variant missing 'bitrate' key\")\n        if 'url' not in variant:\n            raise KeyError(\"Variant missing 'url' key\")\n        \n        # Validate that bitrate is a numeric value\n        bitrate = variant['bitrate']\n        if not isinstance(bitrate, (int, float)):\n            raise TypeError(f\"Bitrate must be numeric, got {type(bitrate).__name__}\")\n        \n        # Select this variant if it has higher bitrate than current highest\n        # or if this is the first video/mp4 variant we've encountered\n        if (highest_bitrate_variant is None or \n            bitrate > highest_bitrate_variant['bitrate']):\n            highest_bitrate_variant = variant\n    \n    # If no video/mp4 variant was found, raise an error\n    if highest_bitrate_variant is None:\n        raise IndexError(\"No video/mp4 variant found in the provided list\")\n    \n    # Return the URL of the highest bitrate video/mp4 variant\n    return highest_bitrate_variant['url']\n\n\n# Note: The unit tests provided in the original request are already comprehensive and\n# will continue to pass with this improved implementation. No changes to the tests\n# are needed.", "test_code": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_case_1(self):\n        # Test purpose: Verify the function returns the correct URL for the highest bitrate video/mp4 variant\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 1000},\n            {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 750}\n        ]\n        self.assertEqual(get_best_video(variants), 'url2')\n\n    def test_case_2(self):\n        # Test purpose: Verify the function handles a single video variant correctly\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 500}\n        ]\n        self.assertEqual(get_best_video(variants), 'url1')\n\n    def test_case_3(self):\n        # Test purpose: Verify the function ignores non-video/mp4 content types and selects only from video/mp4\n        variants = [\n            {'url': 'url1', 'content_type': 'audio/mpeg', 'bitrate': 2000},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 800},\n            {'url': 'url3', 'content_type': 'application/x-mpegURL', 'bitrate': 3000}\n        ]\n        self.assertEqual(get_best_video(variants), 'url2')\n\n    def test_case_4(self):\n        # Test purpose: Verify the function works when video/mp4 variants are not in order of bitrate\n        variants = [\n            {'url': 'url1', 'content_type': 'video/mp4', 'bitrate': 1200},\n            {'url': 'url2', 'content_type': 'video/mp4', 'bitrate': 600},\n            {'url': 'url3', 'content_type': 'video/mp4', 'bitrate': 1500},\n            {'url': 'url4', 'content_type': 'video/mp4', 'bitrate': 900}\n        ]\n        self.assertEqual(get_best_video(variants), 'url3')\n\n    def test_case_5(self):\n        # Test purpose: Verify the function raises an IndexError when given an empty list\n        with self.assertRaises(IndexError):\n            get_best_video([])", "status": ["pass", {}], "timestamp": "2025-08-27T14:31:51.214726"}}
{"id": "85cdf67b-2ce3-35c3-8a4c-c8835720fa22_0", "original": {"code": "import random\n\ndef prob_value(p):\n    q = int(10 * p)\n    l = [1] * q + [0] * (10 - q)\n    item = random.sample(l, 1)[0]\n    return item\n", "test_code": "import unittest\nimport random\n\n# Fix the random seed for reproducible testing\nrandom.seed(42)\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Set a fixed seed for consistent test results\n        self._original_seed = random.getstate()\n        random.seed(42)\n    \n    def tearDown(self):\n        # Restore original random state after each test\n        random.setstate(self._original_seed)\n\n    def test_case_1(self):\n        # Test purpose: Verify the function returns 1 for p = 1.0 (100% probability)\n        result = prob_value(1.0)\n        self.assertEqual(result, 1, \"For p=1.0, output should always be 1\")\n\n    def test_case_2(self):\n        # Test purpose: Verify the function returns 0 for p = 0.0 (0% probability)\n        result = prob_value(0.0)\n        self.assertEqual(result, 0, \"For p=0.0, output should always be 0\")\n\n    def test_case_3(self):\n        # Test purpose: Verify correct behavior for p = 0.5 (50% probability)\n        # Should create list with five 1s and five 0s\n        p = 0.5\n        results = [prob_value(p) for _ in range(1000)]\n        self.assertIn(0, results, \"Output should include 0 for p=0.5\")\n        self.assertIn(1, results, \"Output should include 1 for p=0.5\")\n        # Roughly half should be 1s (within reasonable statistical bounds)\n        count_ones = sum(results)\n        self.assertTrue(400 <= count_ones <= 600, f\"Expected ~50% ones for p=0.5, got {count_ones}/1000\")\n\n    def test_case_4(self):\n        # Test purpose: Verify correct behavior for p = 0.7 (70% probability)\n        p = 0.7\n        results = [prob_value(p) for _ in range(1000)]\n        self.assertIn(0, results, \"Output should include 0 for p=0.7\")\n        self.assertIn(1, results, \"Output should include 1 for p=0.7\")\n        # Should have ~70% ones\n        count_ones = sum(results)\n        self.assertTrue(600 <= count_ones <= 800, f\"Expected ~70% ones for p=0.7, got {count_ones}/1000\")\n\n    def test_case_5(self):\n        # Test purpose: Verify function handles p > 1.0 (clamped to 1.0)\n        result = prob_value(1.5)\n        self.assertEqual(result, 1, \"For p>1.0, function should treat as p=1.0\")\n\n    def test_case_6(self):\n        # Test purpose: Verify function handles p < 0.0 (clamped to 0.0)\n        result = prob_value(-0.5)\n        self.assertEqual(result, 0, \"For p<0.0, function should treat as p=0.0\")\n\n    def test_case_7(self):\n        # Test purpose: Verify exact list composition logic for p=0.3\n        p = 0.3\n        q = int(10 * p)  # Should be 3\n        l = [1] * q + [0] * (10 - q)  # [1,1,1,0,0,0,0,0,0,0]\n        self.assertEqual(len(l), 10, \"List length should always be 10\")\n        self.assertEqual(sum(l), 3, \"For p=0.3, list should contain exactly 3 ones\")\n\n    def test_case_8(self):\n        # Test purpose: Verify function works with float inputs close to boundaries\n        result_low = prob_value(0.09)  # int(10*0.09)=0 -> all zeros\n        self.assertEqual(result_low, 0, \"For p=0.09, q becomes 0 so output should be 0\")\n        \n        result_high = prob_value(0.99)  # int(10*0.99)=9 -> nine ones\n        # Since we can't predict single sample, just ensure it's valid\n        self.assertIn(result_high, [0, 1], \"Output must be either 0 or 1\")", "status": ["pass", {}]}, "debug_rounds": [], "polished": true, "polished_result": null, "polish": {"code": "import random\nfrom typing import Union\n\n\ndef prob_value(p: Union[int, float]) -> int:\n    \"\"\"\n    Generate a binary outcome (0 or 1) based on a given probability.\n    \n    This function simulates a Bernoulli trial where the probability of returning 1\n    is approximately equal to the input probability `p`. The probability is quantized\n    to the nearest tenth (i.e., 0.1 resolution) by creating a list of 10 elements\n    where the number of 1s corresponds to `int(10 * clamped_p)`.\n\n    The input probability is clamped to the range [0.0, 1.0], so values outside this\n    range are treated as 0.0 (for p < 0) or 1.0 (for p > 1).\n\n    Parameters\n    ----------\n    p : int or float\n        The desired probability of returning 1. Will be clamped to [0.0, 1.0].\n        Values are quantized to 1 decimal place precision due to the underlying\n        implementation using a 10-element sample space.\n\n    Returns\n    -------\n    int\n        Returns 1 with approximate probability `p` (clamped and quantized), \n        otherwise returns 0.\n\n    Requirements\n    ------------\n    - random module must be available (standard library)\n\n    Raises\n    ------\n    TypeError\n        If `p` is not a number (int or float).\n\n    Examples\n    --------\n    >>> prob_value(0.7)  # Returns 1 ~70% of the time\n    1\n    >>> prob_value(0.0)\n    0\n    >>> prob_value(1.0)\n    1\n    >>> prob_value(1.5)  # Values > 1.0 are clamped to 1.0\n    1\n    >>> prob_value(-0.5)  # Values < 0.0 are clamped to 0.0\n    0\n    \"\"\"\n    # Input validation\n    if not isinstance(p, (int, float)):\n        raise TypeError(f\"Probability must be a number, got {type(p).__name__}\")\n    \n    # Handle special cases first for efficiency and clarity\n    if p >= 1.0:\n        return 1\n    if p <= 0.0:\n        return 0\n    \n    # Quantize probability to nearest 0.1 by scaling and truncating\n    # This creates a discrete probability space with 10 possible slots\n    q = int(10 * p)  # Number of 1s in the sample list (0-9)\n    \n    # Create a list with q ones and (10-q) zeros\n    # This represents a sample space where P(1) = q/10 â‰ˆ p\n    sample_space = [1] * q + [0] * (10 - q)\n    \n    # Randomly select one item from the sample space\n    # Using random.choice() is more efficient and clearer than random.sample(..., 1)[0]\n    return random.choice(sample_space)\n\n\n# Note: The unit tests provided in the original request are comprehensive and well-structured.\n# They cover edge cases, boundary conditions, statistical behavior, and implementation details.\n# No changes to the tests are needed as they appropriately validate the function's behavior.", "test_code": "import unittest\nimport random\n\n# Fix the random seed for reproducible testing\nrandom.seed(42)\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Set a fixed seed for consistent test results\n        self._original_seed = random.getstate()\n        random.seed(42)\n    \n    def tearDown(self):\n        # Restore original random state after each test\n        random.setstate(self._original_seed)\n\n    def test_case_1(self):\n        # Test purpose: Verify the function returns 1 for p = 1.0 (100% probability)\n        result = prob_value(1.0)\n        self.assertEqual(result, 1, \"For p=1.0, output should always be 1\")\n\n    def test_case_2(self):\n        # Test purpose: Verify the function returns 0 for p = 0.0 (0% probability)\n        result = prob_value(0.0)\n        self.assertEqual(result, 0, \"For p=0.0, output should always be 0\")\n\n    def test_case_3(self):\n        # Test purpose: Verify correct behavior for p = 0.5 (50% probability)\n        # Should create list with five 1s and five 0s\n        p = 0.5\n        results = [prob_value(p) for _ in range(1000)]\n        self.assertIn(0, results, \"Output should include 0 for p=0.5\")\n        self.assertIn(1, results, \"Output should include 1 for p=0.5\")\n        # Roughly half should be 1s (within reasonable statistical bounds)\n        count_ones = sum(results)\n        self.assertTrue(400 <= count_ones <= 600, f\"Expected ~50% ones for p=0.5, got {count_ones}/1000\")\n\n    def test_case_4(self):\n        # Test purpose: Verify correct behavior for p = 0.7 (70% probability)\n        p = 0.7\n        results = [prob_value(p) for _ in range(1000)]\n        self.assertIn(0, results, \"Output should include 0 for p=0.7\")\n        self.assertIn(1, results, \"Output should include 1 for p=0.7\")\n        # Should have ~70% ones\n        count_ones = sum(results)\n        self.assertTrue(600 <= count_ones <= 800, f\"Expected ~70% ones for p=0.7, got {count_ones}/1000\")\n\n    def test_case_5(self):\n        # Test purpose: Verify function handles p > 1.0 (clamped to 1.0)\n        result = prob_value(1.5)\n        self.assertEqual(result, 1, \"For p>1.0, function should treat as p=1.0\")\n\n    def test_case_6(self):\n        # Test purpose: Verify function handles p < 0.0 (clamped to 0.0)\n        result = prob_value(-0.5)\n        self.assertEqual(result, 0, \"For p<0.0, function should treat as p=0.0\")\n\n    def test_case_7(self):\n        # Test purpose: Verify exact list composition logic for p=0.3\n        p = 0.3\n        q = int(10 * p)  # Should be 3\n        l = [1] * q + [0] * (10 - q)  # [1,1,1,0,0,0,0,0,0,0]\n        self.assertEqual(len(l), 10, \"List length should always be 10\")\n        self.assertEqual(sum(l), 3, \"For p=0.3, list should contain exactly 3 ones\")\n\n    def test_case_8(self):\n        # Test purpose: Verify function works with float inputs close to boundaries\n        result_low = prob_value(0.09)  # int(10*0.09)=0 -> all zeros\n        self.assertEqual(result_low, 0, \"For p=0.09, q becomes 0 so output should be 0\")\n        \n        result_high = prob_value(0.99)  # int(10*0.99)=9 -> nine ones\n        # Since we can't predict single sample, just ensure it's valid\n        self.assertIn(result_high, [0, 1], \"Output must be either 0 or 1\")", "status": ["pass", {}], "timestamp": "2025-08-27T14:31:56.426097"}}
{"id": "fae1edc5-6774-353f-b90b-fe4320ffeeb3_1", "original": {"code": "def get_media(tweet):\n    try:\n        variants = tweet.extended_entities['media'][0]['video_info']['variants'\n            ]\n        return get_best_video(variants)\n    except:\n        return False\n", "test_code": "import unittest\nfrom unittest.mock import Mock\n\ndef get_best_video(variants):\n    # Mock implementation of get_best_video for test purposes\n    if not variants:\n        return None\n    # Return the variant with the highest bitrate, assuming 'bitrate' key exists\n    return max((v for v in variants if 'bitrate' in v), key=lambda x: x['bitrate'])\n\ndef get_media(tweet):\n    try:\n        variants = tweet.extended_entities['media'][0]['video_info']['variants']\n        return get_best_video(variants)\n    except:\n        return False\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test purpose: Verify the function returns the best video when valid video variants are present\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {\n                    'variants': [\n                        {'bitrate': 800000, 'url': 'url1'},\n                        {'bitrate': 1200000, 'url': 'url2'},\n                        {'bitrate': 400000, 'url': 'url3'}\n                    ]\n                }\n            }]\n        }\n        result = get_media(tweet)\n        self.assertEqual(result['bitrate'], 1200000)\n        self.assertEqual(result['url'], 'url2')\n\n    def test_case_2(self):\n        # Test purpose: Verify the function returns False when extended_entities is missing\n        tweet = Mock()\n        tweet.extended_entities = {}\n        result = get_media(tweet)\n        self.assertFalse(result)\n\n    def test_case_3(self):\n        # Test purpose: Verify the function returns False when media list is empty\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': []\n        }\n        result = get_media(tweet)\n        self.assertFalse(result)\n\n    def test_case_4(self):\n        # Test purpose: Verify the function returns False when video_info is missing\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {}\n            }]\n        }\n        result = get_media(tweet)\n        self.assertFalse(result)\n\n    def test_case_5(self):\n        # Test purpose: Verify the function returns False when variants list is missing\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {\n                    'variants': []\n                }\n            }]\n        }\n        result = get_media(tweet)\n        self.assertFalse(result)\n\n    def test_case_6(self):\n        # Test purpose: Verify the function handles non-video media gracefully (no bitrate)\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {\n                    'variants': [\n                        {'url': 'image.jpg'},  # No bitrate\n                        {'url': 'audio.mp3'}   # No bitrate\n                    ]\n                }\n            }]\n        }\n        result = get_media(tweet)\n        self.assertFalse(result)  # get_best_video would raise ValueError if no valid variant, but try-except catches it\n\n    def test_case_7(self):\n        # Test purpose: Verify the function returns the only video when one variant exists\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {\n                    'variants': [\n                        {'bitrate': 900000, 'url': 'single_url'}\n                    ]\n                }\n            }]\n        }\n        result = get_media(tweet)\n        self.assertEqual(result['bitrate'], 900000)\n        self.assertEqual(result['url'], 'single_url')\n\n    def test_case_8(self):\n        # Test purpose: Verify the function handles missing extended_entities attribute\n        tweet = Mock()\n        del tweet.extended_entities\n        result = get_media(tweet)\n        self.assertFalse(result)", "status": ["pass", {}]}, "debug_rounds": [], "polished": true, "polished_result": null, "polish": {"code": "from typing import Any, Dict, List, Optional, Union\nfrom unittest.mock import Mock  # Only for testing; not required in production code\n\ndef get_best_video(variants: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Return the video variant with the highest bitrate from a list of video variants.\n    \n    Args:\n        variants: A list of dictionaries representing video variants, each potentially\n                  containing keys like 'bitrate' and 'url'.\n    \n    Returns:\n        The dictionary (variant) with the highest 'bitrate' value, or None if no variant\n        contains a 'bitrate' key or if the list is empty.\n    \n    Example:\n        >>> variants = [\n        ...     {'bitrate': 800000, 'url': 'url1'},\n        ...     {'bitrate': 1200000, 'url': 'url2'}\n        ... ]\n        >>> get_best_video(variants)\n        {'bitrate': 1200000, 'url': 'url2'}\n    \"\"\"\n    try:\n        # Filter variants that have a 'bitrate' key and return the one with max bitrate\n        valid_variants = [v for v in variants if 'bitrate' in v]\n        return max(valid_variants, key=lambda x: x['bitrate']) if valid_variants else None\n    except (ValueError, TypeError):\n        # In case max() fails (e.g., empty sequence after filtering)\n        return None\n\n\ndef get_media(tweet: Any) -> Union[Dict[str, Any], bool]:\n    \"\"\"\n    Extract the best quality video variant from a tweet's extended entities.\n    \n    This function navigates through the tweet object to access video variants and selects\n    the one with the highest bitrate using `get_best_video`. If any part of the expected\n    structure is missing or invalid, it returns False.\n\n    Args:\n        tweet: A tweet object (typically from Tweepy or similar Twitter API wrapper)\n               that may contain an `extended_entities` attribute with media and video info.\n\n    Returns:\n        A dictionary representing the best video variant (with highest bitrate), or\n        False if:\n        - `extended_entities` is missing or not accessible\n        - 'media' list is missing or empty\n        - First media item lacks 'video_info'\n        - 'video_info' lacks 'variants' or it's empty\n        - No variant contains a 'bitrate' field\n        - Any other access error occurs during traversal\n\n    Requirements:\n        The tweet object must follow the Twitter API JSON structure where video media\n        is nested under `extended_entities['media'][0]['video_info']['variants']`.\n\n    Raises:\n        AttributeError: If `tweet` does not have the `extended_entities` attribute.\n        KeyError/IndexError: If expected keys or indices are missing in the data structure.\n        However, these exceptions are caught internally and result in returning False.\n\n    Examples:\n        >>> tweet = Mock()\n        >>> tweet.extended_entities = {\n        ...     'media': [{\n        ...         'video_info': {\n        ...             'variants': [\n        ...                 {'bitrate': 800000, 'url': 'low.mp4'},\n        ...                 {'bitrate': 1200000, 'url': 'high.mp4'}\n        ...             ]\n        ...         }\n        ...     }]\n        ... }\n        >>> result = get_media(tweet)\n        >>> result['bitrate']\n        1200000\n        >>> result['url']\n        'high.mp4'\n\n        >>> tweet_bad = Mock()\n        >>> result = get_media(tweet_bad)  # No extended_entities set\n        >>> result\n        False\n    \"\"\"\n    try:\n        # Safely navigate through the nested tweet structure to get video variants\n        # Check if extended_entities exists and contains 'media' with at least one item\n        if not hasattr(tweet, 'extended_entities'):\n            return False\n        \n        media_list = tweet.extended_entities.get('media', [])\n        if not isinstance(media_list, list) or len(media_list) == 0:\n            return False\n\n        first_media = media_list[0]\n        video_info = first_media.get('video_info', {})\n        if not isinstance(video_info, dict):\n            return False\n\n        variants = video_info.get('variants', [])\n        if not isinstance(variants, list) or len(variants) == 0:\n            return False\n\n        # Delegate selection of best video to helper function\n        best_video = get_best_video(variants)\n\n        # Return False if no suitable video variant was found\n        return best_video if best_video is not None else False\n\n    except (AttributeError, KeyError, IndexError, TypeError):\n        # Catch any data access errors due to missing or malformed structure\n        return False", "test_code": "import unittest\nfrom unittest.mock import Mock\n\ndef get_best_video(variants):\n    # Mock implementation of get_best_video for test purposes\n    if not variants:\n        return None\n    # Return the variant with the highest bitrate, assuming 'bitrate' key exists\n    return max((v for v in variants if 'bitrate' in v), key=lambda x: x['bitrate'])\n\ndef get_media(tweet):\n    try:\n        variants = tweet.extended_entities['media'][0]['video_info']['variants']\n        return get_best_video(variants)\n    except:\n        return False\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test purpose: Verify the function returns the best video when valid video variants are present\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {\n                    'variants': [\n                        {'bitrate': 800000, 'url': 'url1'},\n                        {'bitrate': 1200000, 'url': 'url2'},\n                        {'bitrate': 400000, 'url': 'url3'}\n                    ]\n                }\n            }]\n        }\n        result = get_media(tweet)\n        self.assertEqual(result['bitrate'], 1200000)\n        self.assertEqual(result['url'], 'url2')\n\n    def test_case_2(self):\n        # Test purpose: Verify the function returns False when extended_entities is missing\n        tweet = Mock()\n        tweet.extended_entities = {}\n        result = get_media(tweet)\n        self.assertFalse(result)\n\n    def test_case_3(self):\n        # Test purpose: Verify the function returns False when media list is empty\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': []\n        }\n        result = get_media(tweet)\n        self.assertFalse(result)\n\n    def test_case_4(self):\n        # Test purpose: Verify the function returns False when video_info is missing\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {}\n            }]\n        }\n        result = get_media(tweet)\n        self.assertFalse(result)\n\n    def test_case_5(self):\n        # Test purpose: Verify the function returns False when variants list is missing\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {\n                    'variants': []\n                }\n            }]\n        }\n        result = get_media(tweet)\n        self.assertFalse(result)\n\n    def test_case_6(self):\n        # Test purpose: Verify the function handles non-video media gracefully (no bitrate)\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {\n                    'variants': [\n                        {'url': 'image.jpg'},  # No bitrate\n                        {'url': 'audio.mp3'}   # No bitrate\n                    ]\n                }\n            }]\n        }\n        result = get_media(tweet)\n        self.assertFalse(result)  # get_best_video would raise ValueError if no valid variant, but try-except catches it\n\n    def test_case_7(self):\n        # Test purpose: Verify the function returns the only video when one variant exists\n        tweet = Mock()\n        tweet.extended_entities = {\n            'media': [{\n                'video_info': {\n                    'variants': [\n                        {'bitrate': 900000, 'url': 'single_url'}\n                    ]\n                }\n            }]\n        }\n        result = get_media(tweet)\n        self.assertEqual(result['bitrate'], 900000)\n        self.assertEqual(result['url'], 'single_url')\n\n    def test_case_8(self):\n        # Test purpose: Verify the function handles missing extended_entities attribute\n        tweet = Mock()\n        del tweet.extended_entities\n        result = get_media(tweet)\n        self.assertFalse(result)", "status": ["pass", {}], "timestamp": "2025-08-27T14:31:59.035017"}}
{"id": "e5bbbacc-eb58-3e88-964b-1a82b05055a6_4", "original": {"code": "import numpy as np\n\ndef sample_char(preds, temperature=1.0):\n    \"\"\"\n    Sample a character from the predicted probability distribution.\n    The distribution is first reweighted according to the temperature parameter, then a character is\n    sampled from the reweighted distribution.\n    \"\"\"\n    preds = np.asarray(preds).astype('float64')\n    preds = np.log(preds) / temperature\n    exp_preds = np.exp(preds)\n    preds = exp_preds / np.sum(exp_preds)\n    probas = np.random.multinomial(1, preds, 1)\n    return np.argmax(probas)\n", "test_code": "import unittest\nimport numpy as np\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Set a fixed random seed for reproducible tests\n        np.random.seed(42)\n    \n    def test_normal_input_high_temperature(self):\n        \"\"\"Test with normal probability-like input and temperature > 1.0 (increases randomness)\"\"\"\n        preds = [0.1, 0.2, 0.3, 0.4]\n        temperature = 2.0\n        result = sample_char(preds, temperature)\n        # Result should be an integer index within range\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_normal_input_low_temperature(self):\n        \"\"\"Test with normal input and temperature < 1.0 (makes distribution peakier)\"\"\"\n        preds = [0.1, 0.2, 0.3, 0.4]\n        temperature = 0.5\n        result = sample_char(preds, temperature)\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_normal_input_temperature_one(self):\n        \"\"\"Test with normal input and temperature = 1.0 (no reweighting effect)\"\"\"\n        preds = [0.1, 0.2, 0.3, 0.4]\n        temperature = 1.0\n        result = sample_char(preds, temperature)\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_single_element_input(self):\n        \"\"\"Test when input has only one element\"\"\"\n        preds = [1.0]\n        result = sample_char(preds, temperature=1.0)\n        self.assertEqual(result, 0)\n    \n    def test_equal_probabilities(self):\n        \"\"\"Test with equal input probabilities\"\"\"\n        preds = [0.25, 0.25, 0.25, 0.25]\n        result = sample_char(preds, temperature=1.0)\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_high_temperature_extreme(self):\n        \"\"\"Test very high temperature (approaching uniform distribution)\"\"\"\n        preds = [0.9, 0.1]\n        temperature = 1000.0\n        result = sample_char(preds, temperature)\n        self.assertIn(result, [0, 1])\n    \n    def test_low_temperature_extreme(self):\n        \"\"\"Test very low temperature (approaching one-hot distribution)\"\"\"\n        preds = [0.1, 0.2, 0.7]\n        temperature = 0.01\n        result = sample_char(preds, temperature)\n        # With very low temperature, highest probability item should dominate\n        self.assertEqual(result, 2)  # Should pick the index with highest probability\n    \n    def test_input_as_numpy_array(self):\n        \"\"\"Test that function works when input is already a numpy array\"\"\"\n        preds = np.array([0.2, 0.3, 0.5])\n        result = sample_char(preds, temperature=1.0)\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_input_with_small_values(self):\n        \"\"\"Test with small probability values\"\"\"\n        preds = [1e-5, 0.1, 0.9 - 1e-5]\n        result = sample_char(preds, temperature=1.0)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_numerical_stability_edge_case(self):\n        \"\"\"Test edge case where some predictions are very small\"\"\"\n        preds = [1e-10, 1.0 - 1e-10]\n        result = sample_char(preds, temperature=1.0)\n        self.assertIn(result, [0, 1])\n    \n    @patch('numpy.random.multinomial')\n    def test_sampling_behavior_mocked(self, mock_multinomial):\n        \"\"\"Test that np.random.multinomial is called correctly\"\"\"\n        preds = [0.3, 0.7]\n        mock_multinomial.return_value = np.array([[0, 1]])\n        \n        result = sample_char(preds, temperature=1.0)\n        \n        mock_multinomial.assert_called_once()\n        args = mock_multinomial.call_args[0]\n        self.assertEqual(args[0], 1)\n        self.assertEqual(len(args[1]), 2)\n        self.assertAlmostEqual(sum(args[1]), 1.0, places=6)\n        self.assertEqual(args[2], 1)\n        self.assertEqual(result, 1)", "status": ["pass", {}]}, "debug_rounds": [], "polished": true, "polished_result": null, "polish": {"code": "import numpy as np\nfrom typing import Union, List, Sequence\n\ndef sample_char(preds: Union[Sequence[float], np.ndarray], temperature: float = 1.0) -> np.integer:\n    \"\"\"\n    Sample an index from a probability distribution using temperature-based reweighting.\n    \n    This function implements temperature-controlled sampling, commonly used in text generation\n    and other sequence modeling tasks. The temperature parameter controls the randomness of predictions:\n    - temperature > 1.0: increases randomness (flatter distribution)\n    - temperature = 1.0: no change to the original distribution\n    - 0 < temperature < 1.0: decreases randomness (sharper, more confident distribution)\n    \n    The function applies the softmax transformation after scaling the log-probabilities by temperature.\n    This ensures numerical stability and proper probability normalization.\n    \n    Args:\n        preds: A sequence (list, tuple, or numpy array) of non-negative numbers representing\n               the predicted probabilities or logits. If probabilities, they should sum to ~1.0.\n               Values are automatically normalized after temperature scaling.\n        temperature: A positive float controlling the randomness of sampling. Must be > 0.\n                     Default is 1.0 (no reweighting).\n    \n    Returns:\n        np.integer: The index of the sampled element from the distribution. This represents\n                   which \"character\" or class was selected.\n    \n    Raises:\n        ValueError: If temperature is less than or equal to zero.\n        ValueError: If preds is empty.\n        ValueError: If any value in preds is negative.\n        TypeError: If preds contains non-numeric values.\n    \n    Requirements:\n        numpy: Used for numerical operations, array handling, and random sampling.\n    \n    Examples:\n        >>> np.random.seed(42)  # For reproducible examples\n        >>> sample_char([0.1, 0.2, 0.3, 0.4], temperature=1.0)\n        3\n        \n        >>> sample_char([0.1, 0.2, 0.3, 0.4], temperature=0.5)  # More peaky\n        3\n        \n        >>> sample_char([0.1, 0.2, 0.3, 0.4], temperature=2.0)  # More uniform\n        1\n        \n        >>> sample_char([1.0])  # Single element always returns 0\n        0\n    \"\"\"\n    # Input validation\n    if temperature <= 0:\n        raise ValueError(f\"Temperature must be positive, got {temperature}\")\n    \n    # Convert input to numpy array for consistent processing\n    try:\n        preds = np.asarray(preds).astype('float64')\n    except (ValueError, TypeError) as e:\n        raise TypeError(f\"Input preds must be a sequence of numeric values: {e}\")\n    \n    # Validate array contents\n    if preds.size == 0:\n        raise ValueError(\"Input preds cannot be empty\")\n    \n    if np.any(preds < 0):\n        raise ValueError(\"All values in preds must be non-negative\")\n    \n    # Handle single element case directly for efficiency and to avoid division by zero\n    if preds.size == 1:\n        return np.int64(0)\n    \n    # For numerical stability, add small epsilon to avoid log(0)\n    # This handles cases with very small probabilities that might underflow\n    epsilon = np.finfo(preds.dtype).eps\n    preds = preds + epsilon\n    \n    # Normalize to ensure we're working with a proper distribution\n    # This handles cases where input is logits or unnormalized scores\n    preds = preds / np.sum(preds)\n    \n    # Apply temperature scaling using the softmax formula:\n    # p_i = exp(log(p_i) / T) / sum(exp(log(p_j) / T))\n    # This is mathematically equivalent to (p_i^(1/T)) / sum(p_j^(1/T))\n    preds = np.log(preds) / temperature\n    exp_preds = np.exp(preds)\n    \n    # Renormalize to get the final temperature-scaled probability distribution\n    scaled_probs = exp_preds / np.sum(exp_preds)\n    \n    # Sample from the multinomial distribution (equivalent to categorical sampling)\n    # We sample one trial from a multinomial distribution with n=1\n    sampled = np.random.multinomial(1, scaled_probs, 1)\n    \n    # Return the index of the selected class/character\n    return np.argmax(sampled)", "test_code": "import unittest\nimport numpy as np\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Set a fixed random seed for reproducible tests\n        np.random.seed(42)\n    \n    def test_normal_input_high_temperature(self):\n        \"\"\"Test with normal probability-like input and temperature > 1.0 (increases randomness)\"\"\"\n        preds = [0.1, 0.2, 0.3, 0.4]\n        temperature = 2.0\n        result = sample_char(preds, temperature)\n        # Result should be an integer index within range\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_normal_input_low_temperature(self):\n        \"\"\"Test with normal input and temperature < 1.0 (makes distribution peakier)\"\"\"\n        preds = [0.1, 0.2, 0.3, 0.4]\n        temperature = 0.5\n        result = sample_char(preds, temperature)\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_normal_input_temperature_one(self):\n        \"\"\"Test with normal input and temperature = 1.0 (no reweighting effect)\"\"\"\n        preds = [0.1, 0.2, 0.3, 0.4]\n        temperature = 1.0\n        result = sample_char(preds, temperature)\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_single_element_input(self):\n        \"\"\"Test when input has only one element\"\"\"\n        preds = [1.0]\n        result = sample_char(preds, temperature=1.0)\n        self.assertEqual(result, 0)\n    \n    def test_equal_probabilities(self):\n        \"\"\"Test with equal input probabilities\"\"\"\n        preds = [0.25, 0.25, 0.25, 0.25]\n        result = sample_char(preds, temperature=1.0)\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_high_temperature_extreme(self):\n        \"\"\"Test very high temperature (approaching uniform distribution)\"\"\"\n        preds = [0.9, 0.1]\n        temperature = 1000.0\n        result = sample_char(preds, temperature)\n        self.assertIn(result, [0, 1])\n    \n    def test_low_temperature_extreme(self):\n        \"\"\"Test very low temperature (approaching one-hot distribution)\"\"\"\n        preds = [0.1, 0.2, 0.7]\n        temperature = 0.01\n        result = sample_char(preds, temperature)\n        # With very low temperature, highest probability item should dominate\n        self.assertEqual(result, 2)  # Should pick the index with highest probability\n    \n    def test_input_as_numpy_array(self):\n        \"\"\"Test that function works when input is already a numpy array\"\"\"\n        preds = np.array([0.2, 0.3, 0.5])\n        result = sample_char(preds, temperature=1.0)\n        self.assertIsInstance(result, np.integer)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_input_with_small_values(self):\n        \"\"\"Test with small probability values\"\"\"\n        preds = [1e-5, 0.1, 0.9 - 1e-5]\n        result = sample_char(preds, temperature=1.0)\n        self.assertIn(result, range(len(preds)))\n    \n    def test_numerical_stability_edge_case(self):\n        \"\"\"Test edge case where some predictions are very small\"\"\"\n        preds = [1e-10, 1.0 - 1e-10]\n        result = sample_char(preds, temperature=1.0)\n        self.assertIn(result, [0, 1])\n    \n    @patch('numpy.random.multinomial')\n    def test_sampling_behavior_mocked(self, mock_multinomial):\n        \"\"\"Test that np.random.multinomial is called correctly\"\"\"\n        preds = [0.3, 0.7]\n        mock_multinomial.return_value = np.array([[0, 1]])\n        \n        result = sample_char(preds, temperature=1.0)\n        \n        mock_multinomial.assert_called_once()\n        args = mock_multinomial.call_args[0]\n        self.assertEqual(args[0], 1)\n        self.assertEqual(len(args[1]), 2)\n        self.assertAlmostEqual(sum(args[1]), 1.0, places=6)\n        self.assertEqual(args[2], 1)\n        self.assertEqual(result, 1)", "status": ["pass", {}], "timestamp": "2025-08-27T14:32:03.740996"}}
{"id": "96008757-d6c7-3259-8bf8-354fa1291893_0", "original": {"code": "import pandas as pd\n\ndef insert_row(row_num, df, row_value):\n    \"\"\"\n    This function inserts a row into a DataFrame at a specific position.\n    \"\"\"\n    df1 = df[0:row_num].copy()\n    df2 = df[row_num:].copy()\n    df1.loc[row_num] = row_value\n    df = pd.concat([df1, df2])\n    df.index = [*range(df.shape[0])]\n    return df\n", "test_code": "import unittest\nimport pandas as pd\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Initialize a sample DataFrame for testing\n        self.df = pd.DataFrame({\n            'A': [1, 2, 4, 5],\n            'B': ['a', 'b', 'd', 'e'],\n            'C': [1.1, 2.2, 4.4, 5.5]\n        })\n\n    def test_insert_at_beginning(self):\n        # Test purpose: Verify that a row can be inserted at the beginning (row_num = 0)\n        row_value = [0, 'x', 0.0]\n        result = insert_row(0, self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[0]), row_value)\n\n    def test_insert_at_end(self):\n        # Test purpose: Verify that a row can be inserted at the end (row_num = len(df))\n        row_value = [6, 'f', 6.6]\n        result = insert_row(len(self.df), self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[4]), row_value)\n\n    def test_insert_in_middle(self):\n        # Test purpose: Verify that a row can be inserted in the middle (e.g., row_num = 2)\n        row_value = [3, 'c', 3.3]\n        result = insert_row(2, self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[2]), row_value)\n        self.assertEqual(list(result.loc[3]), [4, 'd', 4.4])  # Original row shifted down\n\n    def test_insert_with_single_column_df(self):\n        # Test purpose: Verify function works with a single-column DataFrame\n        df_single = pd.DataFrame({'X': [10, 20, 30]})\n        row_value = [15]\n        result = insert_row(1, df_single, row_value)\n        self.assertEqual(result.shape, (4, 1))\n        self.assertEqual(result.loc[1, 'X'], 15)\n\n    def test_insert_with_empty_row_value(self):\n        # Test purpose: Verify behavior when row_value has incorrect length (too few values)\n        row_value = [1]\n        with self.assertRaises(ValueError):\n            insert_row(1, self.df, row_value)\n\n    def test_insert_with_extra_values_in_row_value(self):\n        # Test purpose: Verify behavior when row_value has more values than columns\n        row_value = [1, 'x', 1.1, 'extra']\n        with self.assertRaises(ValueError):\n            insert_row(1, self.df, row_value)\n\n    def test_insert_at_negative_index(self):\n        # Test purpose: Verify behavior when row_num is negative (invalid)\n        row_value = [0, 'x', 0.0]\n        result = insert_row(-1, self.df, row_value)  # Should treat -1 as 0 due to slicing\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[0]), row_value)\n\n    def test_insert_at_out_of_bounds_index(self):\n        # Test purpose: Verify inserting beyond the last index (should append)\n        row_value = [99, 'z', 99.9]\n        result = insert_row(100, self.df, row_value)  # Larger than df length\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[4]), row_value)\n\n    def test_original_dataframe_unchanged(self):\n        # Test purpose: Verify the original DataFrame is not modified\n        df_copy = self.df.copy()\n        row_value = [0, 'x', 0.0]\n        insert_row(1, self.df, row_value)\n        pd.testing.assert_frame_equal(self.df, df_copy)  # Original should be unchanged\n\n    def test_preserve_column_names(self):\n        # Test purpose: Verify column names are preserved after insertion\n        row_value = [0, 'x', 0.0]\n        result = insert_row(1, self.df, row_value)\n        pd.testing.assert_index_equal(result.columns, self.df.columns)\n\n    def test_empty_dataframe_insertion(self):\n        # Test purpose: Verify insertion into an empty DataFrame\n        empty_df = pd.DataFrame(columns=['A', 'B', 'C'])\n        row_value = [1, 'a', 1.1]\n        result = insert_row(0, empty_df, row_value)\n        self.assertEqual(result.shape, (1, 3))\n        self.assertEqual(list(result.loc[0]), row_value)", "status": ["fail", {"test_insert_at_negative_index": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_insert_at_negative_index\nAssertionError: Lists differ: [1, 'a', 1.1] != [0, 'x', 0.0]\n\nFirst differing element 0:\n1\n0\n\n- [1, 'a', 1.1]\n+ [0, 'x', 0.0]\n"}]}, "debug_rounds": [[{"code": "import pandas as pd\n\ndef insert_row(row_num, df, row_value):\n    \"\"\"\n    This function inserts a row into a DataFrame at a specific position.\n    \"\"\"\n    # Validate row_value length\n    if len(row_value) != len(df.columns):\n        raise ValueError(\"Row value length does not match number of columns\")\n    \n    # Handle negative row_num by treating it as 0\n    if row_num < 0:\n        row_num = 0\n    \n    # Handle out of bounds row_num by capping it at len(df)\n    row_num = min(row_num, len(df))\n    \n    # Create copies to avoid modifying original dataframe\n    df1 = df.iloc[:row_num].copy()\n    df2 = df.iloc[row_num:].copy()\n    \n    # Create new row as DataFrame\n    new_row = pd.DataFrame([row_value], columns=df.columns, index=[row_num])\n    \n    # Concatenate the parts\n    result = pd.concat([df1, new_row, df2], ignore_index=True)\n    \n    return result", "test_code": "import unittest\nimport pandas as pd\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Initialize a sample DataFrame for testing\n        self.df = pd.DataFrame({\n            'A': [1, 2, 4, 5],\n            'B': ['a', 'b', 'd', 'e'],\n            'C': [1.1, 2.2, 4.4, 5.5]\n        })\n\n    def test_insert_at_beginning(self):\n        # Test purpose: Verify that a row can be inserted at the beginning (row_num = 0)\n        row_value = [0, 'x', 0.0]\n        result = insert_row(0, self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[0]), row_value)\n\n    def test_insert_at_end(self):\n        # Test purpose: Verify that a row can be inserted at the end (row_num = len(df))\n        row_value = [6, 'f', 6.6]\n        result = insert_row(len(self.df), self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[4]), row_value)\n\n    def test_insert_in_middle(self):\n        # Test purpose: Verify that a row can be inserted in the middle (e.g., row_num = 2)\n        row_value = [3, 'c', 3.3]\n        result = insert_row(2, self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[2]), row_value)\n        self.assertEqual(list(result.loc[3]), [4, 'd', 4.4])  # Original row shifted down\n\n    def test_insert_with_single_column_df(self):\n        # Test purpose: Verify function works with a single-column DataFrame\n        df_single = pd.DataFrame({'X': [10, 20, 30]})\n        row_value = [15]\n        result = insert_row(1, df_single, row_value)\n        self.assertEqual(result.shape, (4, 1))\n        self.assertEqual(result.loc[1, 'X'], 15)\n\n    def test_insert_with_empty_row_value(self):\n        # Test purpose: Verify behavior when row_value has incorrect length (too few values)\n        row_value = [1]\n        with self.assertRaises(ValueError):\n            insert_row(1, self.df, row_value)\n\n    def test_insert_with_extra_values_in_row_value(self):\n        # Test purpose: Verify behavior when row_value has more values than columns\n        row_value = [1, 'x', 1.1, 'extra']\n        with self.assertRaises(ValueError):\n            insert_row(1, self.df, row_value)\n\n    def test_insert_at_negative_index(self):\n        # Test purpose: Verify behavior when row_num is negative (invalid)\n        row_value = [0, 'x', 0.0]\n        result = insert_row(-1, self.df, row_value)  # Should treat -1 as 0 due to slicing\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[0]), row_value)\n\n    def test_insert_at_out_of_bounds_index(self):\n        # Test purpose: Verify inserting beyond the last index (should append)\n        row_value = [99, 'z', 99.9]\n        result = insert_row(100, self.df, row_value)  # Larger than df length\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[4]), row_value)\n\n    def test_original_dataframe_unchanged(self):\n        # Test purpose: Verify the original DataFrame is not modified\n        df_copy = self.df.copy()\n        row_value = [0, 'x', 0.0]\n        insert_row(1, self.df, row_value)\n        pd.testing.assert_frame_equal(self.df, df_copy)  # Original should be unchanged\n\n    def test_preserve_column_names(self):\n        # Test purpose: Verify column names are preserved after insertion\n        row_value = [0, 'x', 0.0]\n        result = insert_row(1, self.df, row_value)\n        pd.testing.assert_index_equal(result.columns, self.df.columns)\n\n    def test_empty_dataframe_insertion(self):\n        # Test purpose: Verify insertion into an empty DataFrame\n        empty_df = pd.DataFrame(columns=['A', 'B', 'C'])\n        row_value = [1, 'a', 1.1]\n        result = insert_row(0, empty_df, row_value)\n        self.assertEqual(result.shape, (1, 3))\n        self.assertEqual(list(result.loc[0]), row_value)", "status": ["pass", {}], "round": 0}, {"code": "import pandas as pd\n\ndef insert_row(row_num, df, row_value):\n    \"\"\"\n    This function inserts a row into a DataFrame at a specific position.\n    \"\"\"\n    # Validate row_value length\n    if len(row_value) != len(df.columns):\n        raise ValueError(\"Row value length does not match number of columns\")\n    \n    # Handle negative row_num by treating it as 0\n    if row_num < 0:\n        row_num = 0\n    \n    # Handle out of bounds row_num by capping it at len(df)\n    row_num = min(row_num, len(df))\n    \n    # Create copies to avoid modifying original DataFrame\n    df1 = df.iloc[:row_num].copy()\n    df2 = df.iloc[row_num:].copy()\n    \n    # Create new row as DataFrame\n    new_row = pd.DataFrame([row_value], columns=df.columns, index=[row_num])\n    \n    # Concatenate the parts\n    result = pd.concat([df1, new_row, df2], ignore_index=True)\n    \n    return result", "test_code": "import unittest\nimport pandas as pd\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Initialize a sample DataFrame for testing\n        self.df = pd.DataFrame({\n            'A': [1, 2, 4, 5],\n            'B': ['a', 'b', 'd', 'e'],\n            'C': [1.1, 2.2, 4.4, 5.5]\n        })\n\n    def test_insert_at_beginning(self):\n        # Test purpose: Verify that a row can be inserted at the beginning (row_num = 0)\n        row_value = [0, 'x', 0.0]\n        result = insert_row(0, self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[0]), row_value)\n\n    def test_insert_at_end(self):\n        # Test purpose: Verify that a row can be inserted at the end (row_num = len(df))\n        row_value = [6, 'f', 6.6]\n        result = insert_row(len(self.df), self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[4]), row_value)\n\n    def test_insert_in_middle(self):\n        # Test purpose: Verify that a row can be inserted in the middle (e.g., row_num = 2)\n        row_value = [3, 'c', 3.3]\n        result = insert_row(2, self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[2]), row_value)\n        self.assertEqual(list(result.loc[3]), [4, 'd', 4.4])  # Original row shifted down\n\n    def test_insert_with_single_column_df(self):\n        # Test purpose: Verify function works with a single-column DataFrame\n        df_single = pd.DataFrame({'X': [10, 20, 30]})\n        row_value = [15]\n        result = insert_row(1, df_single, row_value)\n        self.assertEqual(result.shape, (4, 1))\n        self.assertEqual(result.loc[1, 'X'], 15)\n\n    def test_insert_with_empty_row_value(self):\n        # Test purpose: Verify behavior when row_value has incorrect length (too few values)\n        row_value = [1]\n        with self.assertRaises(ValueError):\n            insert_row(1, self.df, row_value)\n\n    def test_insert_with_extra_values_in_row_value(self):\n        # Test purpose: Verify behavior when row_value has more values than columns\n        row_value = [1, 'x', 1.1, 'extra']\n        with self.assertRaises(ValueError):\n            insert_row(1, self.df, row_value)\n\n    def test_insert_at_negative_index(self):\n        # Test purpose: Verify behavior when row_num is negative (invalid)\n        row_value = [0, 'x', 0.0]\n        result = insert_row(-1, self.df, row_value)  # Should treat -1 as 0 due to slicing\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[0]), row_value)\n\n    def test_insert_at_out_of_bounds_index(self):\n        # Test purpose: Verify inserting beyond the last index (should append)\n        row_value = [99, 'z', 99.9]\n        result = insert_row(100, self.df, row_value)  # Larger than df length\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[4]), row_value)\n\n    def test_original_dataframe_unchanged(self):\n        # Test purpose: Verify the original DataFrame is not modified\n        df_copy = self.df.copy()\n        row_value = [0, 'x', 0.0]\n        insert_row(1, self.df, row_value)\n        pd.testing.assert_frame_equal(self.df, df_copy)  # Original should be unchanged\n\n    def test_preserve_column_names(self):\n        # Test purpose: Verify column names are preserved after insertion\n        row_value = [0, 'x', 0.0]\n        result = insert_row(1, self.df, row_value)\n        pd.testing.assert_index_equal(result.columns, self.df.columns)\n\n    def test_empty_dataframe_insertion(self):\n        # Test purpose: Verify insertion into an empty DataFrame\n        empty_df = pd.DataFrame(columns=['A', 'B', 'C'])\n        row_value = [1, 'a', 1.1]\n        result = insert_row(0, empty_df, row_value)\n        self.assertEqual(result.shape, (1, 3))\n        self.assertEqual(list(result.loc[0]), row_value)", "status": ["pass", {}], "round": 0}]], "polished": true, "polished_result": null, "polish": {"code": "import pandas as pd\nfrom typing import List, Any\n\ndef insert_row(row_num: int, df: pd.DataFrame, row_value: List[Any]) -> pd.DataFrame:\n    \"\"\"\n    Insert a new row into a DataFrame at a specified position.\n    \n    This function creates a new DataFrame with the specified row inserted at the given\n    position. The original DataFrame remains unchanged. Row positions are zero-indexed,\n    and out-of-bounds indices are handled gracefully by capping them to valid ranges.\n    \n    Parameters\n    ----------\n    row_num : int\n        The index position where the new row should be inserted.\n        - Negative values are treated as 0 (insert at beginning)\n        - Values greater than the DataFrame length are capped to len(df) (insert at end)\n    df : pd.DataFrame\n        The input DataFrame to insert the row into. This DataFrame is not modified.\n    row_value : List[Any]\n        A list of values to form the new row. The length must exactly match the number \n        of columns in the DataFrame.\n    \n    Returns\n    -------\n    pd.DataFrame\n        A new DataFrame with the row inserted at the specified position. The index is \n        reset to sequential integers starting from 0.\n    \n    Requirements\n    ------------\n    - pandas: Required for DataFrame operations\n    - The length of row_value must equal the number of columns in df\n    \n    Raises\n    ------\n    ValueError\n        If the length of row_value does not match the number of columns in the DataFrame.\n    TypeError\n        If df is not a pandas DataFrame or row_value is not a list-like object.\n    \n    Examples\n    --------\n    >>> import pandas as pd\n    >>> df = pd.DataFrame({'A': [1, 3], 'B': ['a', 'c']})\n    >>> new_row = [2, 'b']\n    >>> result = insert_row(1, df, new_row)\n    >>> print(result)\n       A  B\n    0  1  a\n    1  2  b\n    2  3  c\n    \n    >>> # Insert at beginning\n    >>> result = insert_row(0, df, [0, 'x'])\n    >>> # Insert at end\n    >>> result = insert_row(len(df), df, [4, 'd'])\n    \"\"\"\n    \n    # Input validation\n    if not isinstance(df, pd.DataFrame):\n        raise TypeError(f\"Expected df to be a pandas DataFrame, got {type(df).__name__}\")\n    \n    if not isinstance(row_value, (list, tuple)):\n        raise TypeError(f\"Expected row_value to be a list or tuple, got {type(row_value).__name__}\")\n    \n    # Validate that row_value length matches number of columns in DataFrame\n    if len(row_value) != len(df.columns):\n        raise ValueError(\n            f\"Row value length ({len(row_value)}) does not match \"\n            f\"number of columns ({len(df.columns)})\"\n        )\n    \n    # Handle edge cases for row_num\n    # Negative indices are treated as inserting at the beginning\n    if row_num < 0:\n        row_num = 0\n    \n    # Out-of-bounds indices (greater than DataFrame length) are capped to len(df)\n    # This effectively appends the row at the end\n    row_num = min(row_num, len(df))\n    \n    # Create copies of the DataFrame segments to avoid any potential \n    # modification of the original DataFrame\n    # df1: all rows before the insertion point\n    df1 = df.iloc[:row_num].copy()\n    \n    # df2: all rows from the insertion point onward\n    df2 = df.iloc[row_num:].copy()\n    \n    # Create a new DataFrame containing just the row to be inserted\n    # Use the same column names as the original DataFrame and set the index to row_num\n    # This helps maintain consistency, though the final concat will reset the index\n    new_row = pd.DataFrame([row_value], columns=df.columns, index=[row_num])\n    \n    # Concatenate the three parts: rows before insertion, new row, rows after insertion\n    # ignore_index=True resets the index to sequential integers, which is typically desired\n    result = pd.concat([df1, new_row, df2], ignore_index=True)\n    \n    return result", "test_code": "import unittest\nimport pandas as pd\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Initialize a sample DataFrame for testing\n        self.df = pd.DataFrame({\n            'A': [1, 2, 4, 5],\n            'B': ['a', 'b', 'd', 'e'],\n            'C': [1.1, 2.2, 4.4, 5.5]\n        })\n\n    def test_insert_at_beginning(self):\n        # Test purpose: Verify that a row can be inserted at the beginning (row_num = 0)\n        row_value = [0, 'x', 0.0]\n        result = insert_row(0, self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[0]), row_value)\n\n    def test_insert_at_end(self):\n        # Test purpose: Verify that a row can be inserted at the end (row_num = len(df))\n        row_value = [6, 'f', 6.6]\n        result = insert_row(len(self.df), self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[4]), row_value)\n\n    def test_insert_in_middle(self):\n        # Test purpose: Verify that a row can be inserted in the middle (e.g., row_num = 2)\n        row_value = [3, 'c', 3.3]\n        result = insert_row(2, self.df, row_value)\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[2]), row_value)\n        self.assertEqual(list(result.loc[3]), [4, 'd', 4.4])  # Original row shifted down\n\n    def test_insert_with_single_column_df(self):\n        # Test purpose: Verify function works with a single-column DataFrame\n        df_single = pd.DataFrame({'X': [10, 20, 30]})\n        row_value = [15]\n        result = insert_row(1, df_single, row_value)\n        self.assertEqual(result.shape, (4, 1))\n        self.assertEqual(result.loc[1, 'X'], 15)\n\n    def test_insert_with_empty_row_value(self):\n        # Test purpose: Verify behavior when row_value has incorrect length (too few values)\n        row_value = [1]\n        with self.assertRaises(ValueError):\n            insert_row(1, self.df, row_value)\n\n    def test_insert_with_extra_values_in_row_value(self):\n        # Test purpose: Verify behavior when row_value has more values than columns\n        row_value = [1, 'x', 1.1, 'extra']\n        with self.assertRaises(ValueError):\n            insert_row(1, self.df, row_value)\n\n    def test_insert_at_negative_index(self):\n        # Test purpose: Verify behavior when row_num is negative (invalid)\n        row_value = [0, 'x', 0.0]\n        result = insert_row(-1, self.df, row_value)  # Should treat -1 as 0 due to slicing\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[0]), row_value)\n\n    def test_insert_at_out_of_bounds_index(self):\n        # Test purpose: Verify inserting beyond the last index (should append)\n        row_value = [99, 'z', 99.9]\n        result = insert_row(100, self.df, row_value)  # Larger than df length\n        self.assertEqual(result.shape, (5, 3))\n        self.assertEqual(list(result.loc[4]), row_value)\n\n    def test_original_dataframe_unchanged(self):\n        # Test purpose: Verify the original DataFrame is not modified\n        df_copy = self.df.copy()\n        row_value = [0, 'x', 0.0]\n        insert_row(1, self.df, row_value)\n        pd.testing.assert_frame_equal(self.df, df_copy)  # Original should be unchanged\n\n    def test_preserve_column_names(self):\n        # Test purpose: Verify column names are preserved after insertion\n        row_value = [0, 'x', 0.0]\n        result = insert_row(1, self.df, row_value)\n        pd.testing.assert_index_equal(result.columns, self.df.columns)\n\n    def test_empty_dataframe_insertion(self):\n        # Test purpose: Verify insertion into an empty DataFrame\n        empty_df = pd.DataFrame(columns=['A', 'B', 'C'])\n        row_value = [1, 'a', 1.1]\n        result = insert_row(0, empty_df, row_value)\n        self.assertEqual(result.shape, (1, 3))\n        self.assertEqual(list(result.loc[0]), row_value)", "status": ["pass", {}], "timestamp": "2025-08-27T14:32:12.264329"}}
{"id": "e5bbbacc-eb58-3e88-964b-1a82b05055a6_5", "original": {"code": "import random as rn\n\nimport keras, random, sys, configparser\n\ndef pick_init_seq(text):\n    \"\"\"\n    Pick a random substring from the corpus as the initial sequence.\n    \"\"\"\n    seqlen = cfg.getint('args', 'seqlen')\n    seed_start = random.randint(0, len(text) - seqlen - 1)\n    seed = text[seed_start:seed_start + seqlen]\n    return seed\n", "test_code": "import unittest\nimport random\nimport configparser\n\n# Mock cfg object to simulate config parsing\ncfg = configparser.ConfigParser()\ncfg['args'] = {'seqlen': '10'}\n\n# Import or define the function under test\ndef pick_init_seq(text):\n    \"\"\"\n    Pick a random substring from the corpus as the initial sequence.\n    \"\"\"\n    seqlen = cfg.getint('args', 'seqlen')\n    seed_start = random.randint(0, len(text) - seqlen - 1)\n    seed = text[seed_start:seed_start + seqlen]\n    return seed\n\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Fix random seed for reproducibility in tests\n        random.seed(42)\n        # Sample text for testing\n        self.sample_text = \"This is a sample text used for testing the pick_init_seq function.\"\n\n    def test_normal_case(self):\n        \"\"\"Test that the function returns a valid substring of correct length.\"\"\"\n        result = pick_init_seq(self.sample_text)\n        seqlen = cfg.getint('args', 'seqlen')\n        self.assertEqual(len(result), seqlen)\n        self.assertIn(result, self.sample_text)\n\n    def test_minimum_text_length(self):\n        \"\"\"Test with text that is exactly long enough for one sequence.\"\"\"\n        seqlen = cfg.getint('args', 'seqlen')\n        minimal_text = \"A\" * seqlen  # Exactly seqlen long\n        with self.assertRaises(ValueError):\n            pick_init_seq(minimal_text)  # Should raise because range is invalid\n\n    def test_text_too_short(self):\n        \"\"\"Test behavior when text is shorter than required sequence length.\"\"\"\n        short_text = \"Hi\"\n        with self.assertRaises(ValueError):\n            pick_init_seq(short_text)\n\n    def test_seqlen_one(self):\n        \"\"\"Test with sequence length of 1 (edge case).\"\"\"\n        cfg['args']['seqlen'] = '1'\n        result = pick_init_seq(self.sample_text)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, self.sample_text)\n\n    def test_seqlen_equals_text_length_minus_one(self):\n        \"\"\"Test when seqlen is just one less than text length.\"\"\"\n        seqlen = len(self.sample_text) - 1\n        cfg['args']['seqlen'] = str(seqlen)\n        result = pick_init_seq(self.sample_text)\n        self.assertEqual(len(result), seqlen)\n\n    def test_deterministic_output_with_fixed_seed(self):\n        \"\"\"Test that same result is produced with fixed random seed.\"\"\"\n        random.seed(123)\n        result1 = pick_init_seq(self.sample_text)\n        random.seed(123)\n        result2 = pick_init_seq(self.sample_text)\n        self.assertEqual(result1, result2)\n\n    def test_start_index_within_bounds(self):\n        \"\"\"Test that the selected start index is within valid range.\"\"\"\n        seqlen = cfg.getint('args', 'seqlen')\n        start_index = random.randint(0, len(self.sample_text) - seqlen - 1)\n        self.assertGreaterEqual(start_index, 0)\n        self.assertLessEqual(start_index, len(self.sample_text) - seqlen - 1)\n\n    def test_empty_text_input(self):\n        \"\"\"Test that empty text raises an appropriate error.\"\"\"\n        with self.assertRaises(Exception):\n            pick_init_seq(\"\")\n\n    def test_seqlen_longer_than_text(self):\n        \"\"\"Test when seqlen is greater than the text length.\"\"\"\n        cfg['args']['seqlen'] = '100'\n        with self.assertRaises(ValueError):\n            pick_init_seq(\"short\")\n\n    def tearDown(self):\n        # Reset seqlen to default after tests\n        cfg['args']['seqlen'] = '10'", "status": ["fail", {"ALL": "Descriptors cannot be created directly.\nIf this call came from a _pb2.py file, your generated code is out of date and must be regenerated with protoc >= 3.19.0.\nIf you cannot immediately regenerate your protos, some other possible workarounds are:\n 1. Downgrade the protobuf package to 3.20.x or lower.\n 2. Set PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python (but this will use pure-Python parsing and will be much slower).\n\nMore information: https://developers.google.com/protocol-buffers/docs/news/2022-05-06#python-updates"}]}, "debug_rounds": [[{"code": "import random\nimport configparser\n\n# Global config object\ncfg = configparser.ConfigParser()\ncfg['args'] = {'seqlen': '10'}\n\ndef pick_init_seq(text):\n    \"\"\"\n    Pick a random substring from the corpus as the initial sequence.\n    \"\"\"\n    seqlen = cfg.getint('args', 'seqlen')\n    \n    # Check if text is empty\n    if len(text) == 0:\n        raise ValueError(\"Text is empty\")\n        \n    # Check if seqlen is greater than text length\n    if seqlen > len(text):\n        raise ValueError(f\"Sequence length {seqlen} is greater than text length {len(text)}\")\n        \n    # Check if text is too short to form a valid sequence (must have at least seqlen + 1 chars)\n    if len(text) - seqlen - 1 < 0:\n        raise ValueError(f\"Text too short to extract sequence of length {seqlen}\")\n        \n    seed_start = random.randint(0, len(text) - seqlen - 1)\n    seed = text[seed_start:seed_start + seqlen]\n    return seed", "test_code": "import unittest\nimport random\nimport configparser\n\n# Mock cfg object to simulate config parsing\ncfg = configparser.ConfigParser()\ncfg['args'] = {'seqlen': '10'}\n\n# Import or define the function under test\ndef pick_init_seq(text):\n    \"\"\"\n    Pick a random substring from the corpus as the initial sequence.\n    \"\"\"\n    seqlen = cfg.getint('args', 'seqlen')\n    seed_start = random.randint(0, len(text) - seqlen - 1)\n    seed = text[seed_start:seed_start + seqlen]\n    return seed\n\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Fix random seed for reproducibility in tests\n        random.seed(42)\n        # Sample text for testing\n        self.sample_text = \"This is a sample text used for testing the pick_init_seq function.\"\n\n    def test_normal_case(self):\n        \"\"\"Test that the function returns a valid substring of correct length.\"\"\"\n        result = pick_init_seq(self.sample_text)\n        seqlen = cfg.getint('args', 'seqlen')\n        self.assertEqual(len(result), seqlen)\n        self.assertIn(result, self.sample_text)\n\n    def test_minimum_text_length(self):\n        \"\"\"Test with text that is exactly long enough for one sequence.\"\"\"\n        seqlen = cfg.getint('args', 'seqlen')\n        minimal_text = \"A\" * seqlen  # Exactly seqlen long\n        with self.assertRaises(ValueError):\n            pick_init_seq(minimal_text)  # Should raise because range is invalid\n\n    def test_text_too_short(self):\n        \"\"\"Test behavior when text is shorter than required sequence length.\"\"\"\n        short_text = \"Hi\"\n        with self.assertRaises(ValueError):\n            pick_init_seq(short_text)\n\n    def test_seqlen_one(self):\n        \"\"\"Test with sequence length of 1 (edge case).\"\"\"\n        cfg['args']['seqlen'] = '1'\n        result = pick_init_seq(self.sample_text)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, self.sample_text)\n\n    def test_seqlen_equals_text_length_minus_one(self):\n        \"\"\"Test when seqlen is just one less than text length.\"\"\"\n        seqlen = len(self.sample_text) - 1\n        cfg['args']['seqlen'] = str(seqlen)\n        result = pick_init_seq(self.sample_text)\n        self.assertEqual(len(result), seqlen)\n\n    def test_deterministic_output_with_fixed_seed(self):\n        \"\"\"Test that same result is produced with fixed random seed.\"\"\"\n        random.seed(123)\n        result1 = pick_init_seq(self.sample_text)\n        random.seed(123)\n        result2 = pick_init_seq(self.sample_text)\n        self.assertEqual(result1, result2)\n\n    def test_start_index_within_bounds(self):\n        \"\"\"Test that the selected start index is within valid range.\"\"\"\n        seqlen = cfg.getint('args', 'seqlen')\n        start_index = random.randint(0, len(self.sample_text) - seqlen - 1)\n        self.assertGreaterEqual(start_index, 0)\n        self.assertLessEqual(start_index, len(self.sample_text) - seqlen - 1)\n\n    def test_empty_text_input(self):\n        \"\"\"Test that empty text raises an appropriate error.\"\"\"\n        with self.assertRaises(Exception):\n            pick_init_seq(\"\")\n\n    def test_seqlen_longer_than_text(self):\n        \"\"\"Test when seqlen is greater than the text length.\"\"\"\n        cfg['args']['seqlen'] = '100'\n        with self.assertRaises(ValueError):\n            pick_init_seq(\"short\")\n\n    def tearDown(self):\n        # Reset seqlen to default after tests\n        cfg['args']['seqlen'] = '10'", "status": ["pass", {}], "round": 0}, {"code": "import random\nimport configparser\n\n# Assume cfg is defined globally (as in test setup)\ncfg = configparser.ConfigParser()\ncfg['args'] = {'seqlen': '10'}\n\ndef pick_init_seq(text):\n    \"\"\"\n    Pick a random substring from the corpus as the initial sequence.\n    \"\"\"\n    seqlen = cfg.getint('args', 'seqlen')\n    \n    if len(text) < seqlen:\n        raise ValueError(\"Text length is shorter than sequence length.\")\n    if len(text) == seqlen:\n        raise ValueError(\"Text length equals sequence length; no room for sequence selection with offset.\")\n    \n    seed_start = random.randint(0, len(text) - seqlen - 1)\n    seed = text[seed_start:seed_start + seqlen]\n    return seed", "test_code": "import unittest\nimport random\nimport configparser\n\n# Mock cfg object to simulate config parsing\ncfg = configparser.ConfigParser()\ncfg['args'] = {'seqlen': '10'}\n\n# Import or define the function under test\ndef pick_init_seq(text):\n    \"\"\"\n    Pick a random substring from the corpus as the initial sequence.\n    \"\"\"\n    seqlen = cfg.getint('args', 'seqlen')\n    seed_start = random.randint(0, len(text) - seqlen - 1)\n    seed = text[seed_start:seed_start + seqlen]\n    return seed\n\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Fix random seed for reproducibility in tests\n        random.seed(42)\n        # Sample text for testing\n        self.sample_text = \"This is a sample text used for testing the pick_init_seq function.\"\n\n    def test_normal_case(self):\n        \"\"\"Test that the function returns a valid substring of correct length.\"\"\"\n        result = pick_init_seq(self.sample_text)\n        seqlen = cfg.getint('args', 'seqlen')\n        self.assertEqual(len(result), seqlen)\n        self.assertIn(result, self.sample_text)\n\n    def test_minimum_text_length(self):\n        \"\"\"Test with text that is exactly long enough for one sequence.\"\"\"\n        seqlen = cfg.getint('args', 'seqlen')\n        minimal_text = \"A\" * seqlen  # Exactly seqlen long\n        with self.assertRaises(ValueError):\n            pick_init_seq(minimal_text)  # Should raise because range is invalid\n\n    def test_text_too_short(self):\n        \"\"\"Test behavior when text is shorter than required sequence length.\"\"\"\n        short_text = \"Hi\"\n        with self.assertRaises(ValueError):\n            pick_init_seq(short_text)\n\n    def test_seqlen_one(self):\n        \"\"\"Test with sequence length of 1 (edge case).\"\"\"\n        cfg['args']['seqlen'] = '1'\n        result = pick_init_seq(self.sample_text)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, self.sample_text)\n\n    def test_seqlen_equals_text_length_minus_one(self):\n        \"\"\"Test when seqlen is just one less than text length.\"\"\"\n        seqlen = len(self.sample_text) - 1\n        cfg['args']['seqlen'] = str(seqlen)\n        result = pick_init_seq(self.sample_text)\n        self.assertEqual(len(result), seqlen)\n\n    def test_deterministic_output_with_fixed_seed(self):\n        \"\"\"Test that same result is produced with fixed random seed.\"\"\"\n        random.seed(123)\n        result1 = pick_init_seq(self.sample_text)\n        random.seed(123)\n        result2 = pick_init_seq(self.sample_text)\n        self.assertEqual(result1, result2)\n\n    def test_start_index_within_bounds(self):\n        \"\"\"Test that the selected start index is within valid range.\"\"\"\n        seqlen = cfg.getint('args', 'seqlen')\n        start_index = random.randint(0, len(self.sample_text) - seqlen - 1)\n        self.assertGreaterEqual(start_index, 0)\n        self.assertLessEqual(start_index, len(self.sample_text) - seqlen - 1)\n\n    def test_empty_text_input(self):\n        \"\"\"Test that empty text raises an appropriate error.\"\"\"\n        with self.assertRaises(Exception):\n            pick_init_seq(\"\")\n\n    def test_seqlen_longer_than_text(self):\n        \"\"\"Test when seqlen is greater than the text length.\"\"\"\n        cfg['args']['seqlen'] = '100'\n        with self.assertRaises(ValueError):\n            pick_init_seq(\"short\")\n\n    def tearDown(self):\n        # Reset seqlen to default after tests\n        cfg['args']['seqlen'] = '10'", "status": ["pass", {}], "round": 0}]], "polished": true, "polished_result": null, "polish": {"code": "import random\nimport configparser\n\n\n# Global config object (can be reconfigured externally)\ncfg = configparser.ConfigParser()\ncfg['args'] = {'seqlen': '10'}\n\n\ndef pick_init_seq(text: str) -> str:\n    \"\"\"\n    Pick a random substring of specified length from the input text as the initial sequence.\n    \n    This function selects a uniformly random starting position within the text such that\n    a substring of length `seqlen` can be extracted. The value of `seqlen` is read from\n    the global configuration object `cfg` under section 'args' and key 'seqlen'.\n    \n    The valid starting indices range from 0 to len(text) - seqlen (inclusive). However,\n    the function requires at least one valid position, so the text must be longer than\n    `seqlen`. If not, a ValueError is raised.\n\n    Parameters:\n    -----------\n    text : str\n        The input corpus/text from which to extract the initial sequence.\n        Must be a non-empty string with sufficient length to allow extraction\n        of a substring of length `seqlen`.\n\n    Returns:\n    --------\n    str\n        A substring of length `seqlen` randomly selected from the input text.\n\n    Requirements:\n    -------------\n    - `cfg` must be a valid ConfigParser object with a section 'args' and key 'seqlen'\n      containing an integer value.\n    - The `random` module is used for random selection.\n\n    Raises:\n    -------\n    ValueError\n        If:\n        - `text` is empty.\n        - `seqlen` is greater than the length of `text`.\n        - The text is too short to form a valid sequence (i.e., len(text) <= seqlen),\n          because we need at least one valid starting index (0 to len(text)-seqlen-1).\n    TypeError\n        If `text` is not a string.\n\n    Examples:\n    ---------\n    >>> cfg['args']['seqlen'] = '5'\n    >>> pick_init_seq(\"Hello world\")\n    'o wor'  # Example output (depends on random seed)\n\n    >>> cfg['args']['seqlen'] = '1'\n    >>> pick_init_seq(\"A\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Text too short to extract sequence of length 1\n\n    Notes:\n    ------\n    - To ensure reproducible results, fix the random seed using `random.seed()`.\n    - The function uses inclusive range [0, len(text) - seqlen - 1] for start index,\n      meaning that the maximum starting point allows full `seqlen` extraction.\n    \"\"\"\n    # Input type validation\n    if not isinstance(text, str):\n        raise TypeError(f\"Expected text to be a string, got {type(text).__name__}\")\n\n    # Retrieve sequence length from config\n    try:\n        seqlen = cfg.getint('args', 'seqlen')\n    except (configparser.NoSectionError, configparser.NoOptionError) as e:\n        raise ValueError(f\"Configuration error: {e}. Ensure 'args.seqlen' is set in cfg.\")\n    except ValueError as e:\n        raise ValueError(f\"Invalid value for seqlen: {e}. Must be an integer.\")\n\n    # Validate seqlen is positive\n    if seqlen <= 0:\n        raise ValueError(f\"Sequence length must be positive, got {seqlen}\")\n\n    # Check for empty text\n    if len(text) == 0:\n        raise ValueError(\"Text is empty\")\n\n    # Check if seqlen exceeds text length\n    if seqlen > len(text):\n        raise ValueError(f\"Sequence length {seqlen} is greater than text length {len(text)}\")\n\n    # Check if there's at least one valid starting position\n    # We need: len(text) - seqlen - 1 >= 0  =>  len(text) > seqlen\n    if len(text) <= seqlen:\n        raise ValueError(f\"Text too short to extract sequence of length {seqlen}. \"\n                        f\"Need at least {seqlen + 1} characters.\")\n\n    # Calculate the maximum valid starting index (inclusive)\n    max_start_index = len(text) - seqlen - 1\n\n    # Randomly select a starting index in the valid range [0, max_start_index]\n    seed_start = random.randint(0, max_start_index)\n\n    # Extract and return the substring\n    seed = text[seed_start:seed_start + seqlen]\n    return seed", "test_code": "import unittest\nimport random\nimport configparser\n\n# Mock cfg object to simulate config parsing\ncfg = configparser.ConfigParser()\ncfg['args'] = {'seqlen': '10'}\n\n# Import or define the function under test\ndef pick_init_seq(text):\n    \"\"\"\n    Pick a random substring from the corpus as the initial sequence.\n    \"\"\"\n    seqlen = cfg.getint('args', 'seqlen')\n    seed_start = random.randint(0, len(text) - seqlen - 1)\n    seed = text[seed_start:seed_start + seqlen]\n    return seed\n\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Fix random seed for reproducibility in tests\n        random.seed(42)\n        # Sample text for testing\n        self.sample_text = \"This is a sample text used for testing the pick_init_seq function.\"\n\n    def test_normal_case(self):\n        \"\"\"Test that the function returns a valid substring of correct length.\"\"\"\n        result = pick_init_seq(self.sample_text)\n        seqlen = cfg.getint('args', 'seqlen')\n        self.assertEqual(len(result), seqlen)\n        self.assertIn(result, self.sample_text)\n\n    def test_minimum_text_length(self):\n        \"\"\"Test with text that is exactly long enough for one sequence.\"\"\"\n        seqlen = cfg.getint('args', 'seqlen')\n        minimal_text = \"A\" * seqlen  # Exactly seqlen long\n        with self.assertRaises(ValueError):\n            pick_init_seq(minimal_text)  # Should raise because range is invalid\n\n    def test_text_too_short(self):\n        \"\"\"Test behavior when text is shorter than required sequence length.\"\"\"\n        short_text = \"Hi\"\n        with self.assertRaises(ValueError):\n            pick_init_seq(short_text)\n\n    def test_seqlen_one(self):\n        \"\"\"Test with sequence length of 1 (edge case).\"\"\"\n        cfg['args']['seqlen'] = '1'\n        result = pick_init_seq(self.sample_text)\n        self.assertEqual(len(result), 1)\n        self.assertIn(result, self.sample_text)\n\n    def test_seqlen_equals_text_length_minus_one(self):\n        \"\"\"Test when seqlen is just one less than text length.\"\"\"\n        seqlen = len(self.sample_text) - 1\n        cfg['args']['seqlen'] = str(seqlen)\n        result = pick_init_seq(self.sample_text)\n        self.assertEqual(len(result), seqlen)\n\n    def test_deterministic_output_with_fixed_seed(self):\n        \"\"\"Test that same result is produced with fixed random seed.\"\"\"\n        random.seed(123)\n        result1 = pick_init_seq(self.sample_text)\n        random.seed(123)\n        result2 = pick_init_seq(self.sample_text)\n        self.assertEqual(result1, result2)\n\n    def test_start_index_within_bounds(self):\n        \"\"\"Test that the selected start index is within valid range.\"\"\"\n        seqlen = cfg.getint('args', 'seqlen')\n        start_index = random.randint(0, len(self.sample_text) - seqlen - 1)\n        self.assertGreaterEqual(start_index, 0)\n        self.assertLessEqual(start_index, len(self.sample_text) - seqlen - 1)\n\n    def test_empty_text_input(self):\n        \"\"\"Test that empty text raises an appropriate error.\"\"\"\n        with self.assertRaises(Exception):\n            pick_init_seq(\"\")\n\n    def test_seqlen_longer_than_text(self):\n        \"\"\"Test when seqlen is greater than the text length.\"\"\"\n        cfg['args']['seqlen'] = '100'\n        with self.assertRaises(ValueError):\n            pick_init_seq(\"short\")\n\n    def tearDown(self):\n        # Reset seqlen to default after tests\n        cfg['args']['seqlen'] = '10'", "status": ["pass", {}], "timestamp": "2025-08-27T14:32:55.164649"}}
{"id": "a8630958-4d04-3cb1-b033-04a559b1e1c4_0", "original": {"code": "def formatRepoName(repo_name):\n    tokens = [x.capitalize() for x in repo_name.split('-')]\n    return '-'.join(tokens)\n", "test_code": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_normal_case_with_hyphens(self):\n        # Test purpose: Verify the function correctly capitalizes each word separated by hyphens\n        self.assertEqual(formatRepoName(\"my-repo-name\"), \"My-Repo-Name\")\n\n    def test_single_word_no_hyphens(self):\n        # Test purpose: Verify the function capitalizes a single word with no hyphens\n        self.assertEqual(formatRepoName(\"repo\"), \"Repo\")\n\n    def test_empty_string(self):\n        # Test purpose: Verify the function handles empty string input\n        self.assertEqual(formatRepoName(\"\"), \"\")\n\n    def test_multiple_consecutive_hyphens(self):\n        # Test purpose: Verify behavior when there are consecutive hyphens (creates empty tokens)\n        self.assertEqual(formatRepoName(\"a--b--c\"), \"A--B--C\")\n\n    def test_leading_hyphen(self):\n        # Test purpose: Verify the function handles leading hyphen\n        self.assertEqual(formatRepoName(\"-repo-name\"), \"-Repo-Name\")\n\n    def test_trailing_hyphen(self):\n        # Test purpose: Verify the function handles trailing hyphen\n        self.assertEqual(formatRepoName(\"repo-name-\"), \"Repo-Name-\")\n\n    def test_all_hyphens(self):\n        # Test purpose: Verify the function handles string with only hyphens\n        self.assertEqual(formatRepoName(\"---\"), \"---\")\n\n    def test_mixed_case_input(self):\n        # Test purpose: Verify the function properly capitalizes mixed case input\n        self.assertEqual(formatRepoName(\"my-Repo-NAME\"), \"My-Repo-Name\")\n\n    def test_single_character_tokens(self):\n        # Test purpose: Verify the function works with single character segments\n        self.assertEqual(formatRepoName(\"a-b-c\"), \"A-B-C\")\n\n    def test_long_repo_name(self):\n        # Test purpose: Verify the function handles longer repository names\n        self.assertEqual(formatRepoName(\"very-long-repo-name-example\"), \"Very-Long-Repo-Name-Example\")", "status": ["pass", {}]}, "debug_rounds": [], "polished": true, "polished_result": null, "polish": {"code": "import re\nfrom typing import Optional\n\n\ndef format_repo_name(repo_name: str) -> str:\n    \"\"\"\n    Capitalizes each word in a repository name separated by hyphens while preserving the original structure.\n    \n    This function processes a repository name string by splitting it on hyphens, capitalizing the first \n    letter of each segment (while making the rest lowercase), and then rejoining the segments with hyphens.\n    It preserves empty segments (from consecutive, leading, or trailing hyphens) and maintains the exact\n    hyphen structure of the original string.\n\n    Parameters:\n    -----------\n    repo_name : str\n        The repository name string to format. Expected to be a string composed of alphanumeric \n        characters and hyphens. Can include empty segments (consecutive hyphens), leading/trailing \n        hyphens, or mixed case text.\n\n    Returns:\n    --------\n    str\n        A formatted string where each non-empty segment between hyphens has its first character \n        capitalized and the rest lowercase. The original hyphen structure (including consecutive \n        hyphens, leading, and trailing hyphens) is preserved.\n\n    Requirements:\n    -------------\n    - Input must be a string\n    - No external dependencies beyond Python standard library\n\n    Raises:\n    -------\n    TypeError\n        If the input is not a string\n\n    Examples:\n    ---------\n    >>> format_repo_name(\"my-repo-name\")\n    'My-Repo-Name'\n    \n    >>> format_repo_name(\"repo\")\n    'Repo'\n    \n    >>> format_repo_name(\"\")\n    ''\n    \n    >>> format_repo_name(\"a--b--c\")\n    'A--B--C'\n    \n    >>> format_repo_name(\"-repo-name\")\n    '-Repo-Name'\n    \n    >>> format_repo_name(\"my-Repo-NAME\")\n    'My-Repo-Name'\n    \"\"\"\n    \n    # Input validation: ensure the input is a string\n    if not isinstance(repo_name, str):\n        raise TypeError(f\"Expected string input, got {type(repo_name).__name__}\")\n    \n    # Handle empty string case directly for efficiency\n    if not repo_name:\n        return repo_name\n    \n    # Split the repository name by hyphens to get individual tokens\n    # This preserves empty strings from consecutive/leading/trailing hyphens\n    tokens = repo_name.split('-')\n    \n    # Capitalize each non-empty token (first letter uppercase, rest lowercase)\n    # Empty tokens (from consecutive hyphens) remain as empty strings\n    capitalized_tokens = []\n    for token in tokens:\n        if token:  # Non-empty token\n            # Capitalize first letter, make rest lowercase for consistent formatting\n            capitalized_token = token[0].upper() + token[1:].lower() if len(token) > 1 else token.upper()\n            capitalized_tokens.append(capitalized_token)\n        else:  # Empty token (from consecutive/leading/trailing hyphens)\n            capitalized_tokens.append(token)\n    \n    # Join the processed tokens back together with hyphens\n    # This preserves the original structure including multiple, leading, and trailing hyphens\n    return '-'.join(capitalized_tokens)\n\n\n# Alias the function to maintain backward compatibility with original name\nformatRepoName = format_repo_name", "test_code": "import unittest\n\nclass TestCases(unittest.TestCase):\n    def test_normal_case_with_hyphens(self):\n        # Test purpose: Verify the function correctly capitalizes each word separated by hyphens\n        self.assertEqual(formatRepoName(\"my-repo-name\"), \"My-Repo-Name\")\n\n    def test_single_word_no_hyphens(self):\n        # Test purpose: Verify the function capitalizes a single word with no hyphens\n        self.assertEqual(formatRepoName(\"repo\"), \"Repo\")\n\n    def test_empty_string(self):\n        # Test purpose: Verify the function handles empty string input\n        self.assertEqual(formatRepoName(\"\"), \"\")\n\n    def test_multiple_consecutive_hyphens(self):\n        # Test purpose: Verify behavior when there are consecutive hyphens (creates empty tokens)\n        self.assertEqual(formatRepoName(\"a--b--c\"), \"A--B--C\")\n\n    def test_leading_hyphen(self):\n        # Test purpose: Verify the function handles leading hyphen\n        self.assertEqual(formatRepoName(\"-repo-name\"), \"-Repo-Name\")\n\n    def test_trailing_hyphen(self):\n        # Test purpose: Verify the function handles trailing hyphen\n        self.assertEqual(formatRepoName(\"repo-name-\"), \"Repo-Name-\")\n\n    def test_all_hyphens(self):\n        # Test purpose: Verify the function handles string with only hyphens\n        self.assertEqual(formatRepoName(\"---\"), \"---\")\n\n    def test_mixed_case_input(self):\n        # Test purpose: Verify the function properly capitalizes mixed case input\n        self.assertEqual(formatRepoName(\"my-Repo-NAME\"), \"My-Repo-Name\")\n\n    def test_single_character_tokens(self):\n        # Test purpose: Verify the function works with single character segments\n        self.assertEqual(formatRepoName(\"a-b-c\"), \"A-B-C\")\n\n    def test_long_repo_name(self):\n        # Test purpose: Verify the function handles longer repository names\n        self.assertEqual(formatRepoName(\"very-long-repo-name-example\"), \"Very-Long-Repo-Name-Example\")", "status": ["pass", {}], "timestamp": "2025-08-27T14:34:55.184804"}}
{"id": "01bc6fdc-df6c-35e9-8cb0-f4c700491b9b_1", "original": {"code": "import os\n\ndef download_zip(url):\n    print('downloading...' + url)\n    if not os.path.exists('.cache'):\n        os.makedirs('.cache')\n    dz = '.cache/' + url.split('/')[-1]\n    urllib.request.urlretrieve(url, dz)\n    return dz\n", "test_code": "import unittest\nimport os\nimport tempfile\nimport shutil\nfrom unittest import mock\nimport urllib.request\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Create a temporary directory for testing\n        self.test_dir = tempfile.mkdtemp()\n        self.original_cwd = os.getcwd()\n        os.chdir(self.test_dir)\n        \n        # Mock urllib to prevent actual network calls\n        self.urllib_patcher = mock.patch('urllib.request.urlretrieve')\n        self.mock_urlretrieve = self.urllib_patcher.start()\n    \n    def tearDown(self):\n        # Clean up the temporary directory and restore original directory\n        os.chdir(self.original_cwd)\n        shutil.rmtree(self.test_dir)\n        self.urllib_patcher.stop()\n    \n    def test_download_zip_normal_url(self):\n        # Test purpose: Verify the function handles a normal URL correctly\n        test_url = \"https://example.com/files/data.zip\"\n        result = download_zip(test_url)\n        \n        # Check that the returned path is correct\n        expected_path = '.cache/data.zip'\n        self.assertEqual(result, expected_path)\n        \n        # Check that urlretrieve was called with correct arguments\n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_cache_directory_created(self):\n        # Test purpose: Verify that .cache directory is created if it doesn't exist\n        test_url = \"https://example.com/files/data.zip\"\n        \n        # Ensure .cache doesn't exist initially\n        cache_path = '.cache'\n        if os.path.exists(cache_path):\n            os.rmdir(cache_path)\n            \n        self.assertFalse(os.path.exists(cache_path))\n        \n        download_zip(test_url)\n        \n        # Check that .cache directory was created\n        self.assertTrue(os.path.exists(cache_path))\n        self.assertTrue(os.path.isdir(cache_path))\n    \n    def test_download_zip_cache_directory_exists(self):\n        # Test purpose: Verify function works when .cache directory already exists\n        test_url = \"https://example.com/files/document.zip\"\n        \n        # Create .cache directory manually\n        os.makedirs('.cache', exist_ok=True)\n        \n        # Store initial mock call count\n        initial_call_count = self.mock_urlretrieve.call_count\n        \n        result = download_zip(test_url)\n        \n        # Check return value and that urlretrieve was called once\n        expected_path = '.cache/document.zip'\n        self.assertEqual(result, expected_path)\n        self.assertEqual(self.mock_urlretrieve.call_count, initial_call_count + 1)\n        self.mock_urlretrieve.assert_called_with(test_url, expected_path)\n    \n    def test_download_zip_url_with_query_params(self):\n        # Test purpose: Verify the function handles URLs with query parameters\n        test_url = \"https://example.com/files/data.zip?token=abc123&expires=12345\"\n        result = download_zip(test_url)\n        \n        # The query parameters should not be part of the filename\n        expected_path = '.cache/data.zip'\n        self.assertEqual(result, expected_path)\n        \n        # Check that urlretrieve was called correctly\n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_url_with_no_extension(self):\n        # Test purpose: Verify the function handles URLs without file extensions\n        test_url = \"https://example.com/files/data\"\n        result = download_zip(test_url)\n        \n        expected_path = '.cache/data'\n        self.assertEqual(result, expected_path)\n        \n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_nested_url_path(self):\n        # Test purpose: Verify the function extracts filename correctly from nested paths\n        test_url = \"https://example.com/archive/2023/05/15/final_report.zip\"\n        result = download_zip(test_url)\n        \n        expected_path = '.cache/final_report.zip'\n        self.assertEqual(result, expected_path)\n        \n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_empty_url(self):\n        # Test purpose: Verify behavior with empty URL (edge case)\n        test_url = \"\"\n        with self.assertRaises(Exception):\n            # This will cause issues when splitting, but we want to test resilience\n            # Actually, it will create '.cache/' which ends with '/', which is problematic\n            download_zip(test_url)\n        # Note: The function doesn't validate URL, so we're testing what happens\n        # Let's modify to expect it might still try to proceed\n        try:\n            result = download_zip(test_url)\n            # If it doesn't raise, verify basic behavior\n            self.assertEqual(result, '.cache/')\n        except:\n            pass  # It's acceptable for this edge case to fail\n    \n    def test_download_zip_none_url(self):\n        # Test purpose: Verify behavior with None URL\n        test_url = None\n        with self.assertRaises(AttributeError):\n            # This should raise because None.split() is not valid\n            download_zip(test_url)", "status": ["fail", {"test_download_zip_empty_url": "Traceback (most recent call last):\n  File \"__test__.py\", line 118, in test_download_zip_empty_url\nAssertionError: Exception not raised\n", "test_download_zip_url_with_query_params": "Traceback (most recent call last):\n  File \"__test__.py\", line 90, in test_download_zip_url_with_query_params\nAssertionError: '.cache/data.zip?token=abc123&expires=12345' != '.cache/data.zip'\n- .cache/data.zip?token=abc123&expires=12345\n+ .cache/data.zip\n\n", "test_download_zip_none_url": "Traceback (most recent call last):\n  File \"__test__.py\", line 136, in test_download_zip_none_url\n  File \"__test__.py\", line 4, in download_zip\nTypeError: can only concatenate str (not \"NoneType\") to str\n"}]}, "debug_rounds": [[{"code": "import os\nimport urllib.request\nfrom urllib.parse import urlparse\n\ndef download_zip(url):\n    if url is None:\n        raise AttributeError(\"URL cannot be None\")\n    print('downloading...' + url)\n    if not os.path.exists('.cache'):\n        os.makedirs('.cache')\n    # Extract the filename from the URL, ignoring query parameters\n    filename = os.path.basename(urlparse(url).path)\n    if not filename:  # Handle empty or root path\n        raise ValueError(\"Invalid URL: no filename to download\")\n    dz = '.cache/' + filename\n    urllib.request.urlretrieve(url, dz)\n    return dz", "test_code": "import unittest\nimport os\nimport tempfile\nimport shutil\nfrom unittest import mock\nimport urllib.request\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Create a temporary directory for testing\n        self.test_dir = tempfile.mkdtemp()\n        self.original_cwd = os.getcwd()\n        os.chdir(self.test_dir)\n        \n        # Mock urllib to prevent actual network calls\n        self.urllib_patcher = mock.patch('urllib.request.urlretrieve')\n        self.mock_urlretrieve = self.urllib_patcher.start()\n    \n    def tearDown(self):\n        # Clean up the temporary directory and restore original directory\n        os.chdir(self.original_cwd)\n        shutil.rmtree(self.test_dir)\n        self.urllib_patcher.stop()\n    \n    def test_download_zip_normal_url(self):\n        # Test purpose: Verify the function handles a normal URL correctly\n        test_url = \"https://example.com/files/data.zip\"\n        result = download_zip(test_url)\n        \n        # Check that the returned path is correct\n        expected_path = '.cache/data.zip'\n        self.assertEqual(result, expected_path)\n        \n        # Check that urlretrieve was called with correct arguments\n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_cache_directory_created(self):\n        # Test purpose: Verify that .cache directory is created if it doesn't exist\n        test_url = \"https://example.com/files/data.zip\"\n        \n        # Ensure .cache doesn't exist initially\n        cache_path = '.cache'\n        if os.path.exists(cache_path):\n            os.rmdir(cache_path)\n            \n        self.assertFalse(os.path.exists(cache_path))\n        \n        download_zip(test_url)\n        \n        # Check that .cache directory was created\n        self.assertTrue(os.path.exists(cache_path))\n        self.assertTrue(os.path.isdir(cache_path))\n    \n    def test_download_zip_cache_directory_exists(self):\n        # Test purpose: Verify function works when .cache directory already exists\n        test_url = \"https://example.com/files/document.zip\"\n        \n        # Create .cache directory manually\n        os.makedirs('.cache', exist_ok=True)\n        \n        # Store initial mock call count\n        initial_call_count = self.mock_urlretrieve.call_count\n        \n        result = download_zip(test_url)\n        \n        # Check return value and that urlretrieve was called once\n        expected_path = '.cache/document.zip'\n        self.assertEqual(result, expected_path)\n        self.assertEqual(self.mock_urlretrieve.call_count, initial_call_count + 1)\n        self.mock_urlretrieve.assert_called_with(test_url, expected_path)\n    \n    def test_download_zip_url_with_query_params(self):\n        # Test purpose: Verify the function handles URLs with query parameters\n        test_url = \"https://example.com/files/data.zip?token=abc123&expires=12345\"\n        result = download_zip(test_url)\n        \n        # The query parameters should not be part of the filename\n        expected_path = '.cache/data.zip'\n        self.assertEqual(result, expected_path)\n        \n        # Check that urlretrieve was called correctly\n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_url_with_no_extension(self):\n        # Test purpose: Verify the function handles URLs without file extensions\n        test_url = \"https://example.com/files/data\"\n        result = download_zip(test_url)\n        \n        expected_path = '.cache/data'\n        self.assertEqual(result, expected_path)\n        \n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_nested_url_path(self):\n        # Test purpose: Verify the function extracts filename correctly from nested paths\n        test_url = \"https://example.com/archive/2023/05/15/final_report.zip\"\n        result = download_zip(test_url)\n        \n        expected_path = '.cache/final_report.zip'\n        self.assertEqual(result, expected_path)\n        \n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_empty_url(self):\n        # Test purpose: Verify behavior with empty URL (edge case)\n        test_url = \"\"\n        with self.assertRaises(Exception):\n            # This will cause issues when splitting, but we want to test resilience\n            # Actually, it will create '.cache/' which ends with '/', which is problematic\n            download_zip(test_url)\n        # Note: The function doesn't validate URL, so we're testing what happens\n        # Let's modify to expect it might still try to proceed\n        try:\n            result = download_zip(test_url)\n            # If it doesn't raise, verify basic behavior\n            self.assertEqual(result, '.cache/')\n        except:\n            pass  # It's acceptable for this edge case to fail\n    \n    def test_download_zip_none_url(self):\n        # Test purpose: Verify behavior with None URL\n        test_url = None\n        with self.assertRaises(AttributeError):\n            # This should raise because None.split() is not valid\n            download_zip(test_url)", "status": ["pass", {}], "round": 0}]], "polished": true, "polished_result": null, "polish": {"code": "import os\nimport urllib.request\nfrom urllib.parse import urlparse\nfrom typing import Optional\n\n\ndef download_zip(url: str) -> str:\n    \"\"\"\n    Download a ZIP file (or any file) from a given URL and save it locally in the '.cache' directory.\n    \n    This function ensures the '.cache' directory exists, extracts the filename from the URL\n    (ignoring query parameters), downloads the file, and returns the full local path where\n    the file was saved.\n\n    Parameters:\n    -----------\n    url : str\n        The URL of the file to download. Must not be None or empty. Query parameters are\n        ignored when determining the filename.\n\n    Returns:\n    --------\n    str\n        The local file path (relative to current working directory) where the file was saved,\n        in the format '.cache/filename'.\n\n    Requirements:\n    -------------\n    - The URL must point to a downloadable resource.\n    - Sufficient disk space must be available in the current working directory.\n    - Internet connectivity is required unless `urllib.request.urlretrieve` is mocked.\n\n    Raises:\n    -------\n    AttributeError\n        If the `url` parameter is None.\n    ValueError\n        If the URL does not contain a valid filename (e.g., ends with '/' or has no path).\n    urllib.error.URLError\n        If there is a network issue or the URL is unreachable (during actual download).\n    OSError\n        If there is an issue creating the '.cache' directory or writing the file.\n\n    Examples:\n    ---------\n    >>> download_zip(\"https://example.com/files/data.zip\")\n    '.cache/data.zip'\n\n    >>> download_zip(\"https://example.com/files/report.zip?token=abc123\")\n    '.cache/report.zip'\n\n    >>> download_zip(\"https://example.com/archive/final/document.pdf\")\n    '.cache/document.pdf'\n    \"\"\"\n    # Validate input: URL must not be None\n    if url is None:\n        raise AttributeError(\"URL cannot be None\")\n\n    # Log download initiation\n    print(f'downloading... {url}')\n\n    # Ensure the cache directory exists\n    cache_dir = '.cache'\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir, exist_ok=True)  # Use exist_ok=True for thread safety\n\n    # Parse the URL and extract the filename from the path, ignoring query parameters\n    parsed_url = urlparse(url)\n    filename = os.path.basename(parsed_url.path)\n\n    # Validate that a valid filename was extracted\n    if not filename:\n        raise ValueError(\"Invalid URL: no filename to download. URL path must end with a file name.\")\n\n    # Construct the local destination path\n    destination_path = os.path.join(cache_dir, filename)\n\n    # Download the file from the URL to the local destination\n    urllib.request.urlretrieve(url, destination_path)\n\n    # Return the path to the downloaded file\n    return destination_path", "test_code": "import unittest\nimport os\nimport tempfile\nimport shutil\nfrom unittest import mock\nimport urllib.request\n\nclass TestCases(unittest.TestCase):\n    \n    def setUp(self):\n        # Create a temporary directory for testing\n        self.test_dir = tempfile.mkdtemp()\n        self.original_cwd = os.getcwd()\n        os.chdir(self.test_dir)\n        \n        # Mock urllib to prevent actual network calls\n        self.urllib_patcher = mock.patch('urllib.request.urlretrieve')\n        self.mock_urlretrieve = self.urllib_patcher.start()\n    \n    def tearDown(self):\n        # Clean up the temporary directory and restore original directory\n        os.chdir(self.original_cwd)\n        shutil.rmtree(self.test_dir)\n        self.urllib_patcher.stop()\n    \n    def test_download_zip_normal_url(self):\n        # Test purpose: Verify the function handles a normal URL correctly\n        test_url = \"https://example.com/files/data.zip\"\n        result = download_zip(test_url)\n        \n        # Check that the returned path is correct\n        expected_path = '.cache/data.zip'\n        self.assertEqual(result, expected_path)\n        \n        # Check that urlretrieve was called with correct arguments\n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_cache_directory_created(self):\n        # Test purpose: Verify that .cache directory is created if it doesn't exist\n        test_url = \"https://example.com/files/data.zip\"\n        \n        # Ensure .cache doesn't exist initially\n        cache_path = '.cache'\n        if os.path.exists(cache_path):\n            os.rmdir(cache_path)\n            \n        self.assertFalse(os.path.exists(cache_path))\n        \n        download_zip(test_url)\n        \n        # Check that .cache directory was created\n        self.assertTrue(os.path.exists(cache_path))\n        self.assertTrue(os.path.isdir(cache_path))\n    \n    def test_download_zip_cache_directory_exists(self):\n        # Test purpose: Verify function works when .cache directory already exists\n        test_url = \"https://example.com/files/document.zip\"\n        \n        # Create .cache directory manually\n        os.makedirs('.cache', exist_ok=True)\n        \n        # Store initial mock call count\n        initial_call_count = self.mock_urlretrieve.call_count\n        \n        result = download_zip(test_url)\n        \n        # Check return value and that urlretrieve was called once\n        expected_path = '.cache/document.zip'\n        self.assertEqual(result, expected_path)\n        self.assertEqual(self.mock_urlretrieve.call_count, initial_call_count + 1)\n        self.mock_urlretrieve.assert_called_with(test_url, expected_path)\n    \n    def test_download_zip_url_with_query_params(self):\n        # Test purpose: Verify the function handles URLs with query parameters\n        test_url = \"https://example.com/files/data.zip?token=abc123&expires=12345\"\n        result = download_zip(test_url)\n        \n        # The query parameters should not be part of the filename\n        expected_path = '.cache/data.zip'\n        self.assertEqual(result, expected_path)\n        \n        # Check that urlretrieve was called correctly\n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_url_with_no_extension(self):\n        # Test purpose: Verify the function handles URLs without file extensions\n        test_url = \"https://example.com/files/data\"\n        result = download_zip(test_url)\n        \n        expected_path = '.cache/data'\n        self.assertEqual(result, expected_path)\n        \n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_nested_url_path(self):\n        # Test purpose: Verify the function extracts filename correctly from nested paths\n        test_url = \"https://example.com/archive/2023/05/15/final_report.zip\"\n        result = download_zip(test_url)\n        \n        expected_path = '.cache/final_report.zip'\n        self.assertEqual(result, expected_path)\n        \n        self.mock_urlretrieve.assert_called_once_with(test_url, expected_path)\n    \n    def test_download_zip_empty_url(self):\n        # Test purpose: Verify behavior with empty URL (edge case)\n        test_url = \"\"\n        with self.assertRaises(Exception):\n            # This will cause issues when splitting, but we want to test resilience\n            # Actually, it will create '.cache/' which ends with '/', which is problematic\n            download_zip(test_url)\n        # Note: The function doesn't validate URL, so we're testing what happens\n        # Let's modify to expect it might still try to proceed\n        try:\n            result = download_zip(test_url)\n            # If it doesn't raise, verify basic behavior\n            self.assertEqual(result, '.cache/')\n        except:\n            pass  # It's acceptable for this edge case to fail\n    \n    def test_download_zip_none_url(self):\n        # Test purpose: Verify behavior with None URL\n        test_url = None\n        with self.assertRaises(AttributeError):\n            # This should raise because None.split() is not valid\n            download_zip(test_url)", "status": ["pass", {}], "timestamp": "2025-08-27T14:35:20.804989"}}
{"id": "e16b2e8a-f73b-355c-b8c3-8b4ede805406_4", "original": {"code": "import numpy as np\n\nfrom keras.utils import np_utils\n\nimport numpy as np\n\ndef vec2pad(doc, max_length):\n    doclength, embdim = np.shape(doc)\n    if doclength < max_length:\n        s = np.zeros([max_length - doclength, embdim])\n        doc = np.concatenate((doc, s), axis=0)\n        return doc\n    elif doclength == max_length:\n        return doc\n    else:\n        print('document is longer that the set max_length')\n        return doc\n", "test_code": "import unittest\nimport numpy as np\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test purpose: Verify the function correctly pads a document shorter than max_length\n        doc = np.array([[1, 2], [3, 4]])  # shape (2, 2)\n        max_length = 5\n        result = vec2pad(doc, max_length)\n        expected_shape = (5, 2)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result[:2], doc)  # Original content preserved\n        np.testing.assert_array_equal(result[2:], np.zeros((3, 2)))  # Properly padded with zeros\n\n    def test_case_2(self):\n        # Test purpose: Verify the function returns the same document when length equals max_length\n        doc = np.array([[1, 2], [3, 4], [5, 6]])  # shape (3, 2)\n        max_length = 3\n        result = vec2pad(doc, max_length)\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, doc.shape)\n\n    def test_case_3(self):\n        # Test purpose: Verify the function handles a document longer than max_length (no truncation)\n        doc = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])  # shape (4, 2)\n        max_length = 3\n        with patch('builtins.print') as mock_print:\n            result = vec2pad(doc, max_length)\n            mock_print.assert_called_with('document is longer that the set max_length')\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, doc.shape)\n\n    def test_case_4(self):\n        # Test purpose: Verify the function works with single-dimensional embeddings (embdim = 1)\n        doc = np.array([[1], [2]])  # shape (2, 1)\n        max_length = 4\n        result = vec2pad(doc, max_length)\n        expected_shape = (4, 1)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result[:2], doc)\n        np.testing.assert_array_equal(result[2:], np.zeros((2, 1)))\n\n    def test_case_5(self):\n        # Test purpose: Verify the function handles empty document (zero rows)\n        doc = np.array([]).reshape(0, 3)  # shape (0, 3)\n        max_length = 2\n        result = vec2pad(doc, max_length)\n        expected_shape = (2, 3)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result, np.zeros((2, 3)))\n\n    def test_case_6(self):\n        # Test purpose: Verify the function handles max_length = 0\n        doc = np.array([[1, 2]])  # shape (1, 2)\n        max_length = 0\n        with patch('builtins.print') as mock_print:\n            result = vec2pad(doc, max_length)\n            mock_print.assert_called_with('document is longer that the set max_length')\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, (1, 2))", "status": ["fail", {"ALL": "Descriptors cannot be created directly.\nIf this call came from a _pb2.py file, your generated code is out of date and must be regenerated with protoc >= 3.19.0.\nIf you cannot immediately regenerate your protos, some other possible workarounds are:\n 1. Downgrade the protobuf package to 3.20.x or lower.\n 2. Set PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python (but this will use pure-Python parsing and will be much slower).\n\nMore information: https://developers.google.com/protocol-buffers/docs/news/2022-05-06#python-updates"}]}, "debug_rounds": [[{"code": "import numpy as np\n\ndef vec2pad(doc, max_length):\n    doclength, embdim = doc.shape\n    if doclength < max_length:\n        pad = np.zeros((max_length - doclength, embdim))\n        return np.concatenate((doc, pad), axis=0)\n    elif doclength == max_length:\n        return doc\n    else:\n        print('document is longer that the set max_length')\n        return doc", "test_code": "import unittest\nimport numpy as np\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test purpose: Verify the function correctly pads a document shorter than max_length\n        doc = np.array([[1, 2], [3, 4]])  # shape (2, 2)\n        max_length = 5\n        result = vec2pad(doc, max_length)\n        expected_shape = (5, 2)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result[:2], doc)  # Original content preserved\n        np.testing.assert_array_equal(result[2:], np.zeros((3, 2)))  # Properly padded with zeros\n\n    def test_case_2(self):\n        # Test purpose: Verify the function returns the same document when length equals max_length\n        doc = np.array([[1, 2], [3, 4], [5, 6]])  # shape (3, 2)\n        max_length = 3\n        result = vec2pad(doc, max_length)\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, doc.shape)\n\n    def test_case_3(self):\n        # Test purpose: Verify the function handles a document longer than max_length (no truncation)\n        doc = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])  # shape (4, 2)\n        max_length = 3\n        with patch('builtins.print') as mock_print:\n            result = vec2pad(doc, max_length)\n            mock_print.assert_called_with('document is longer that the set max_length')\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, doc.shape)\n\n    def test_case_4(self):\n        # Test purpose: Verify the function works with single-dimensional embeddings (embdim = 1)\n        doc = np.array([[1], [2]])  # shape (2, 1)\n        max_length = 4\n        result = vec2pad(doc, max_length)\n        expected_shape = (4, 1)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result[:2], doc)\n        np.testing.assert_array_equal(result[2:], np.zeros((2, 1)))\n\n    def test_case_5(self):\n        # Test purpose: Verify the function handles empty document (zero rows)\n        doc = np.array([]).reshape(0, 3)  # shape (0, 3)\n        max_length = 2\n        result = vec2pad(doc, max_length)\n        expected_shape = (2, 3)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result, np.zeros((2, 3)))\n\n    def test_case_6(self):\n        # Test purpose: Verify the function handles max_length = 0\n        doc = np.array([[1, 2]])  # shape (1, 2)\n        max_length = 0\n        with patch('builtins.print') as mock_print:\n            result = vec2pad(doc, max_length)\n            mock_print.assert_called_with('document is longer that the set max_length')\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, (1, 2))", "status": ["pass", {}], "round": 0}, {"code": "import numpy as np\n\ndef vec2pad(doc, max_length):\n    doclength, embdim = np.shape(doc)\n    if doclength < max_length:\n        s = np.zeros([max_length - doclength, embdim])\n        doc = np.concatenate((doc, s), axis=0)\n        return doc\n    elif doclength == max_length:\n        return doc\n    else:\n        print('document is longer that the set max_length')\n        return doc", "test_code": "import unittest\nimport numpy as np\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test purpose: Verify the function correctly pads a document shorter than max_length\n        doc = np.array([[1, 2], [3, 4]])  # shape (2, 2)\n        max_length = 5\n        result = vec2pad(doc, max_length)\n        expected_shape = (5, 2)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result[:2], doc)  # Original content preserved\n        np.testing.assert_array_equal(result[2:], np.zeros((3, 2)))  # Properly padded with zeros\n\n    def test_case_2(self):\n        # Test purpose: Verify the function returns the same document when length equals max_length\n        doc = np.array([[1, 2], [3, 4], [5, 6]])  # shape (3, 2)\n        max_length = 3\n        result = vec2pad(doc, max_length)\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, doc.shape)\n\n    def test_case_3(self):\n        # Test purpose: Verify the function handles a document longer than max_length (no truncation)\n        doc = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])  # shape (4, 2)\n        max_length = 3\n        with patch('builtins.print') as mock_print:\n            result = vec2pad(doc, max_length)\n            mock_print.assert_called_with('document is longer that the set max_length')\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, doc.shape)\n\n    def test_case_4(self):\n        # Test purpose: Verify the function works with single-dimensional embeddings (embdim = 1)\n        doc = np.array([[1], [2]])  # shape (2, 1)\n        max_length = 4\n        result = vec2pad(doc, max_length)\n        expected_shape = (4, 1)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result[:2], doc)\n        np.testing.assert_array_equal(result[2:], np.zeros((2, 1)))\n\n    def test_case_5(self):\n        # Test purpose: Verify the function handles empty document (zero rows)\n        doc = np.array([]).reshape(0, 3)  # shape (0, 3)\n        max_length = 2\n        result = vec2pad(doc, max_length)\n        expected_shape = (2, 3)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result, np.zeros((2, 3)))\n\n    def test_case_6(self):\n        # Test purpose: Verify the function handles max_length = 0\n        doc = np.array([[1, 2]])  # shape (1, 2)\n        max_length = 0\n        with patch('builtins.print') as mock_print:\n            result = vec2pad(doc, max_length)\n            mock_print.assert_called_with('document is longer that the set max_length')\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, (1, 2))", "status": ["pass", {}], "round": 0}]], "polished": true, "polished_result": null, "polish": {"code": "import numpy as np\n\n\ndef vec2pad(doc: np.ndarray, max_length: int) -> np.ndarray:\n    \"\"\"\n    Pads or validates a 2D document embedding matrix to a specified maximum length.\n\n    This function ensures that the input document (a 2D NumPy array of shape (doclength, embdim))\n    has exactly `max_length` rows. If the document is shorter than `max_length`, it is padded\n    with zero vectors along the first axis. If the document is equal to or longer than\n    `max_length`, it is returned unchanged (no truncation is performed), and a warning\n    message is printed if the document exceeds `max_length`.\n\n    Parameters\n    ----------\n    doc : np.ndarray\n        A 2D NumPy array representing the document embeddings with shape (doclength, embdim).\n        Each row corresponds to an embedded token or element.\n    max_length : int\n        The desired maximum number of rows (sequence length) for the output array.\n\n    Returns\n    -------\n    np.ndarray\n        A 2D array with shape (max_length, embdim) if doclength < max_length,\n        otherwise returns the original array with shape (doclength, embdim).\n\n    Requirements\n    ------------\n    - `doc` must be a 2D NumPy array (even if one dimension is zero).\n    - `max_length` must be a non-negative integer.\n\n    Raises\n    ------\n    ValueError\n        If `doc` is not a 2D array.\n    TypeError\n        If `max_length` is not an integer.\n    ValueError\n        If `max_length` is negative.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> doc = np.array([[1, 2], [3, 4]])\n    >>> result = vec2pad(doc, 4)\n    >>> result.shape\n    (4, 2)\n    >>> np.array_equal(result[:2], doc)\n    True\n    >>> np.array_equal(result[2:], np.zeros((2, 2)))\n    True\n\n    >>> doc = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> result = vec2pad(doc, 3)\n    >>> np.array_equal(result, doc)\n    True\n\n    >>> doc = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n    >>> result = vec2pad(doc, 2)  # Prints warning but returns original\n    document is longer that the set max_length\n    >>> np.array_equal(result, doc)\n    True\n    \"\"\"\n    # Input validation\n    if not isinstance(doc, np.ndarray):\n        raise TypeError(\"doc must be a NumPy array\")\n    \n    if doc.ndim != 2:\n        raise ValueError(f\"doc must be a 2D array, but got {doc.ndim}D array\")\n\n    if not isinstance(max_length, int):\n        raise TypeError(f\"max_length must be an integer, but got {type(max_length)}\")\n\n    if max_length < 0:\n        raise ValueError(f\"max_length must be non-negative, but got {max_length}\")\n\n    # Extract dimensions\n    doc_length, emb_dim = doc.shape\n\n    # Case 1: Document is shorter than max_length -> pad with zeros\n    if doc_length < max_length:\n        # Create zero padding with shape (padding_rows, emb_dim)\n        padding = np.zeros((max_length - doc_length, emb_dim), dtype=doc.dtype)\n        # Concatenate original document with padding along axis 0 (rows)\n        padded_doc = np.concatenate((doc, padding), axis=0)\n        return padded_doc\n\n    # Case 2: Document length matches max_length -> return as-is\n    elif doc_length == max_length:\n        return doc.copy()  # Return a copy to avoid unintended mutations\n\n    # Case 3: Document is longer than max_length -> warn and return original\n    else:\n        print('document is longer that the set max_length')\n        return doc.copy()  # Return a copy to maintain consistent behavior", "test_code": "import unittest\nimport numpy as np\nfrom unittest.mock import patch\n\nclass TestCases(unittest.TestCase):\n    \n    def test_case_1(self):\n        # Test purpose: Verify the function correctly pads a document shorter than max_length\n        doc = np.array([[1, 2], [3, 4]])  # shape (2, 2)\n        max_length = 5\n        result = vec2pad(doc, max_length)\n        expected_shape = (5, 2)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result[:2], doc)  # Original content preserved\n        np.testing.assert_array_equal(result[2:], np.zeros((3, 2)))  # Properly padded with zeros\n\n    def test_case_2(self):\n        # Test purpose: Verify the function returns the same document when length equals max_length\n        doc = np.array([[1, 2], [3, 4], [5, 6]])  # shape (3, 2)\n        max_length = 3\n        result = vec2pad(doc, max_length)\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, doc.shape)\n\n    def test_case_3(self):\n        # Test purpose: Verify the function handles a document longer than max_length (no truncation)\n        doc = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])  # shape (4, 2)\n        max_length = 3\n        with patch('builtins.print') as mock_print:\n            result = vec2pad(doc, max_length)\n            mock_print.assert_called_with('document is longer that the set max_length')\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, doc.shape)\n\n    def test_case_4(self):\n        # Test purpose: Verify the function works with single-dimensional embeddings (embdim = 1)\n        doc = np.array([[1], [2]])  # shape (2, 1)\n        max_length = 4\n        result = vec2pad(doc, max_length)\n        expected_shape = (4, 1)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result[:2], doc)\n        np.testing.assert_array_equal(result[2:], np.zeros((2, 1)))\n\n    def test_case_5(self):\n        # Test purpose: Verify the function handles empty document (zero rows)\n        doc = np.array([]).reshape(0, 3)  # shape (0, 3)\n        max_length = 2\n        result = vec2pad(doc, max_length)\n        expected_shape = (2, 3)\n        self.assertEqual(result.shape, expected_shape)\n        np.testing.assert_array_equal(result, np.zeros((2, 3)))\n\n    def test_case_6(self):\n        # Test purpose: Verify the function handles max_length = 0\n        doc = np.array([[1, 2]])  # shape (1, 2)\n        max_length = 0\n        with patch('builtins.print') as mock_print:\n            result = vec2pad(doc, max_length)\n            mock_print.assert_called_with('document is longer that the set max_length')\n        np.testing.assert_array_equal(result, doc)\n        self.assertEqual(result.shape, (1, 2))", "status": ["pass", {}], "timestamp": "2025-08-27T14:35:32.076081"}}
